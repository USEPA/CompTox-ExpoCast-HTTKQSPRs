---
title: "HTTK QSPRs: Level 1 Analysis"
author: "John Wambaugh and Nisha Sipes"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{QSPR Bakeoff}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir= "C:/Users/jwambaug/git/CompTox-ExpoCast-HTTKQSPRs/")
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

First we clear the memory to make sure there are no holdovers from previous R runs
```{r clear_mermor, eval=TRUE}
rm(list=ls()) 
```

To use the code in this vignette, you'll first need to load a few packages (if you haven't already).
```{r load_packages, eval = TRUE}
library(readxl)
library(ggplot2)
library(httk)
library(scales)
library(gplots)
library(RColorBrewer)
library(DescTools)
library(gridExtra)
library(reshape2)
library(knitr)
library(ggpubr)
```

# Load custom code 
```{r load_code, eval = TRUE}
source("clear_httk.R")
source("tkstats.R")
```

# Keep table numbering straight:
```{r load_code, eval = TRUE}
PREV.TABLES <- 3
PREV.SUP.TABLES <- 0
```

# Set the time stamp:
```{r time_stamp, eval = TRUE}
# Time stamp:
output.prefix <- "May2025"
```

```{r load_data, eval= TRUE}
load(file="data/httkinvitro.RData")
load(file="data/Cvt-chems.RData")
load(file="data/Cvt-data.RData")
```


#Level I Predictions -- in vitro TK parameters:

At level I we are comparing QSPR's with the in vitro measured values.
We don't have those values for all the chemicals, so we only are comparing on
a subset.

ADMET (Sipes et al., 2017)
Pradeep et al. (2020)
Dawson et al. (2021)
OPERA (in prep.)
IVBP (Chirico et al., 2021)

Get the in vitro measured values:
In Vitro Measured:
```{r text_for_manuscript, eval = TRUE}
cat(paste("Evaluation data for Clint for",
      sum(sapply(invitro$Human.Clint,function(x) !is.na(x))),
      "chemicals and fup for",
      sum(sapply(invitro$Human.Funbound.plasma,function(x) !is.na(x))),
      ".\n"
      ))
cat("\n")
reset_httk()
tot.zero <- sum(sapply(get_cheminfo(info="Clint",
                                    median.only = TRUE,
                                    suppress.messages = TRUE),
                       function(x) 0%in%x))
tot.clint <- sum(sapply(get_cheminfo(info="Clint",
                                     median.only = TRUE,
                                     suppress.messages=TRUE),
                        function(x) !is.na(x)))
cat("\n")
cat("Discussion\n")
cat(paste(sum(invitro$Human.Clint%in% 0),
          "out of",
          sum(!is.na(invitro$Human.Clint)),
          "chemicals with in vitro HTTK Clint measured data have no observed clearance (that is, they are metabolically stable) compared with",
          tot.zero,
          "out of",
          tot.clint,
          "measured Clint values (",
          signif(tot.zero/tot.clint*100,2),
          "percent) in the httk data set as whole.\n"
          ))
cat("\n")
```

ADMET Predictor:
```{r add_admet, eval = TRUE}
# Simulations Plus (Sipes 2017):
clear_httk()
suppressWarnings(load_sipes2017(overwrite=TRUE))
admet <- subset(get_cheminfo(info="all"),DTXSID %in% CvT.chems$DTXSID)
CvT.chems <- merge(CvT.chems,
  admet[,c("DTXSID","Human.Clint","Human.Funbound.plasma")],
  all.x=TRUE,
  by="DTXSID")
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Clint"] <- "Human.Clint.ADMET"
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Funbound.plasma"] <- "Human.Fup.ADMET"
```

Dawson 2021:
```{r add_dawson, eval = TRUE}
clear_httk()
load_dawson2021(overwrite=TRUE)
dawson <- subset(get_cheminfo(info="all"),DTXSID %in% CvT.chems$DTXSID)
CvT.chems <- merge(CvT.chems,
  dawson[,c("DTXSID","Human.Clint","Human.Funbound.plasma")],
  all.x=TRUE,
  by="DTXSID")
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Clint"] <- "Human.Clint.Dawson"
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Funbound.plasma"] <- 
  "Human.Fup.Dawson"
```

Pradeep 2020:
```{r add_pradeep, eval = TRUE}
clear_httk()
load_pradeep2020(overwrite=TRUE)
pradeep <- subset(get_cheminfo(info="all"),DTXSID %in% CvT.chems$DTXSID)
CvT.chems <- merge(CvT.chems,
  pradeep[,c("DTXSID","Human.Clint","Human.Funbound.plasma")],
  all.x=TRUE,
  by="DTXSID")
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Clint"] <- "Human.Clint.Pradeep"
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Funbound.plasma"] <- 
  "Human.Fup.Pradeep"
```

OPERA Predictor:
```{r add_opera, eval = TRUE}
opera <- read.csv("CvTdb/testchems-smi_OPERA2.7Pred.csv",stringsAsFactors=F)
colnames(opera)[colnames(opera)=="MoleculeID"] <- "DTXSID"
opera <- subset(opera,DTXSID%in%CvT.chems$DTXSID)
# Domain of applicability:
opera[opera$AD_FUB==0,"FUB_pred"] <- NA
opera[opera$AD_Clint==0,"Clint_pred"] <- NA

CvT.chems <- merge(CvT.chems,
  opera[,c("DTXSID","Clint_pred","FUB_pred")],
  all.x=TRUE,
  by="DTXSID")
colnames(CvT.chems)[colnames(CvT.chems)=="Clint_pred"] <- "Human.Clint.OPERA"
colnames(CvT.chems)[colnames(CvT.chems)=="FUB_pred"] <- "Human.Fup.OPERA"
```

IVBP Predictor:
```{r add_ivbp, eval = TRUE}
ivbp <- as.data.frame(read_excel("qsprs/BakeOff_IVBP_Suite.xlsx",sheet=2))
ivbp <- subset(ivbp,DTXSID%in%CvT.chems$DTXSID)
# Domain of applicability:
ivbp[tolower(ivbp[,"AD"])=="out ad","IVBP Final Pred Log Clint_mL/h/10^6 hep"] <- NA

# log to arithmetic:
ivbp[,"IVBP Final Pred Log Clint_mL/h/10^6 hep"] <- 
  10^as.numeric(ivbp[,"IVBP Final Pred Log Clint_mL/h/10^6 hep"])

# h to min:
ivbp[,"IVBP Final Pred Log Clint_mL/h/10^6 hep"] <- 
  ivbp[,"IVBP Final Pred Log Clint_mL/h/10^6 hep"]/60

# mL to uL:
ivbp[,"IVBP Final Pred Log Clint_mL/h/10^6 hep"] <- 
  ivbp[,"IVBP Final Pred Log Clint_mL/h/10^6 hep"] * 1000

CvT.chems <- merge(CvT.chems,
  ivbp[,c("DTXSID","IVBP Final Pred Log Clint_mL/h/10^6 hep")],
  all.x=TRUE,
  by="DTXSID")
colnames(CvT.chems)[colnames(CvT.chems)=="IVBP Final Pred Log Clint_mL/h/10^6 hep"] <- "Human.Clint.IVBP"
#colnames(CvT.chems)[colnames(CvT.chems)=="FUB_pred"] <- "Human.Fup.IVBP
```


Master Table:
```{r prediction_table, eval = TRUE}
for (this.col in 12:(dim(CvT.chems)[2])) 
{
  CvT.chems[,this.col] <- as.numeric(CvT.chems[,this.col])
}

sup.table <- CvT.chems
for (this.col in 1:dim(sup.table)[2])
  if (is.numeric(sup.table[1,this.col]))
    sup.table[,this.col] <- signif(sup.table[,this.col],3)
write.csv(sup.table, 
          row.names=FALSE,
          file=paste("tables/SupTable",
          PREV.SUP.TABLES + 1,
          "-QSPRPredsandInVitroData.txt",
          sep=""))
```

Divide into individual tables:
```{r divide_tables, eval = TRUE}
level1tab <- CvT.chems
colnames(level1tab)[colnames(level1tab) == "CASRN"] <- "CAS"

level1tab1 <- level1tab[,c(
  "DTXSID",
  "PREFERRED_NAME",
  "CAS",
  "Human.Clint.httk","Human.Fup.httk",
  "Human.Clint.ADMET","Human.Fup.ADMET")]
level1tab1$QSPR <- "ADMET"
colnames(level1tab1)[6:7] <- c("Human.Clint.pred","Human.Fup.pred") 

level1tab2 <- level1tab[,c(
  "DTXSID",
  "PREFERRED_NAME",
  "CAS",
  "Human.Clint.httk",
  "Human.Fup.httk",
  "Human.Clint.Dawson",
  "Human.Fup.Dawson")]
level1tab2$QSPR <- "Dawson"
colnames(level1tab2)[6:7] <- c("Human.Clint.pred","Human.Fup.pred")

level1tab3 <- level1tab[,c(
  "DTXSID",
  "PREFERRED_NAME",
  "CAS",
  "Human.Clint.httk",
  "Human.Fup.httk",
  "Human.Clint.Pradeep",
  "Human.Fup.Pradeep")]
level1tab3$QSPR <- "Pradeep"
colnames(level1tab3)[6:7] <- c("Human.Clint.pred","Human.Fup.pred")

level1tab4 <- level1tab[,c(
  "DTXSID",
  "PREFERRED_NAME",
  "CAS",
  "Human.Clint.httk",
  "Human.Fup.httk",
  "Human.Clint.OPERA",
  "Human.Fup.OPERA")]
level1tab4$QSPR <- "OPERA"
colnames(level1tab4)[6:7] <- c("Human.Clint.pred","Human.Fup.pred")

level1tab5 <- level1tab[,c(
  "DTXSID",
  "PREFERRED_NAME",
  "CAS",
  "Human.Clint.httk",
  "Human.Fup.httk",
  "Human.Clint.IVBP")]
# There are no Fup preds for IVBP:
level1tab5 <- cbind(level1tab5,NA)
level1tab5$QSPR <- "IVBP"
colnames(level1tab5)[6:7] <- c("Human.Clint.pred","Human.Fup.pred")


level1tab <- rbind(level1tab1,level1tab2,level1tab3,level1tab4,level1tab5)
level1tab$Human.Fup.pred <- as.numeric(level1tab$Human.Fup.pred)
level1tab$Human.Clint.pred <- as.numeric(level1tab$Human.Clint.pred)
```

## calculate fold error (FE) and absolute fold error (AbsFE)
```{r calc_Level1AbsFE, eval=TRUE}
MINVAL <- 1e-6
#Absolute fold error (AbsFE) : abs(log10(pred/obs))
level1tab$Human.Clint.AbsFE <- abs(log10((level1tab$Human.Clint.pred + MINVAL) /
  (level1tab$Human.Clint.httk + MINVAL)))
level1tab$Human.fup.AbsFE <- abs(log10((level1tab$Human.Fup.pred + MINVAL) /
  (level1tab$Human.Fup.httk + MINVAL)))

# Fo
level1tab$Human.Clint.FE<- log10((level1tab$Human.Clint.pred + MINVAL) /
  level1tab$Human.Clint.httk)
level1tab$Human.fup.FE<- log10((level1tab$Human.Fup.pred + MINVAL) /
  level1tab$Human.Fup.httk)

for (this.row in 1:dim(level1tab)[1])
{
  this.Clint.AbsFE <- level1tab[this.row,"Human.Clint.AbsFE"]
  if (!is.na(this.Clint.AbsFE))
  {
    if (!is.finite(this.Clint.AbsFE)) 
    {
#Turn -Inf and Inf into NA
      level1tab[this.row,"Human.Clint.AbsFE"] <- NA
      level1tab[this.row,"Human.Clint.FE"] <- NA
    }
    if (is.nan(this.Clint.AbsFE)) 
    {
#Turn NaN into 0 , because the NaN is a result of matching 0/0...and hence it was correctly identified.
      level1tab[this.row,"Human.Clint.AbsFE"] <- 0
      level1tab[this.row,"Human.Clint.FE"] <- 0
    }
  }
  this.fup.AbsFE <- level1tab[this.row,"Human.fup.AbsFE"]
  if (!is.na(this.fup.AbsFE))
  {
    if (!is.finite(this.fup.AbsFE)) 
    {
#Turn -Inf and Inf into NA
      level1tab[this.row,"Human.fup.AbsFE"] <- NA
      level1tab[this.row,"Human.fup.FE"] <- NA
    }
    if (is.nan(this.fup.AbsFE)) 
    {
#Turn NaN into 0 , because the NaN is a result of matching 0/0...and hence it was correctly identified.
      level1tab[this.row,"Human.fup.AbsFE"] <- 0
      level1tab[this.row,"Human.fup.FE"] <- 0
    }
  }  
}
```

```{r set_order_shapes}
level1tab$QSPR <- factor(level1tab$QSPR, levels=c("ADMET", "Dawson", "OPERA", 
                                                     "Pradeep", 
                                                     "IVBP"))
ggshapes <- c(21, 22, 23, 24, 25)
ggcolors <- c("Red","Orange","Green","Blue","Purple")
```

# Count the number of predictions
```{r number_predictions, eval = TRUE}
pred.counts <- data.frame()
for (this.qspr in unique(level1tab$QSPR))
{
  pred.counts[this.qspr,"Clint"] <-
    sum(!is.na(subset(level1tab, QSPR==this.qspr)$Human.Clint.pred))
  pred.counts[this.qspr,"Fup"] <-
    sum(!is.na(subset(level1tab, QSPR==this.qspr)$Human.Fup.pred))
}

kable(pred.counts)

write.csv(pred.counts,
          file=paste("tables/SupTable",
          PREV.SUP.TABLES+4,
          "-QSPRPredCounts.txt",
          sep=""))

cat("Supplemental Table 4 gives the per QSPR number of chemicals for which predictions were made. ")
cat(paste("For Clint the number of chemicals with HTTK parameter predictions ranged from a low of ",
          min(pred.counts[,"Clint"],na.rm=TRUE),
          " for the ",
          rownames(pred.counts)[pred.counts$Clint ==
                                  min(pred.counts[,"Clint"],na.rm=TRUE)],
          " QSPR to ",
          max(pred.counts[,"Clint"],na.rm=TRUE),
          " for ",
          rownames(pred.counts)[pred.counts$Clint ==
                                  max(pred.counts[,"Clint"],na.rm=TRUE)],
          ". ",
          sep=""))
cat(paste("For fup",
          rownames(pred.counts)[pred.counts$Fup ==
                                  min(pred.counts[,"Fup"],na.rm=TRUE)],
          " predicted a low of ",
          min(pred.counts[,"Fup"],na.rm=TRUE),
          "chemicals and ",
          rownames(pred.counts)[pred.counts$Fup ==
                                  max(pred.counts[,"Fup"],na.rm=TRUE)],
          " covered a high of ",
          max(pred.counts[,"Fup"],na.rm=TRUE),
          ".",
          sep=""))
```
# For later CvT evaluations we will try to avoid values that are just being retrieved from the training set (as in KNN methods):
```{r fold_error_cutoff, eval = GALSE}
level1tab.withtrainingset <- level1tab
direct.retrieval.table <- NULL
TOOCLOSE.THRESHOLD <- 0.01

for (this.row in 1:dim(level1tab)[1])
{
  this.qspr <- level1tab[this.row,"QSPR"]
  this.dtxsid <- level1tab[this.row,"DTXSID"]
  clint <- level1tab[this.row,"Human.Clint.AbsFE"]
  if (!is.na(clint))
  {
    if (clint < TOOCLOSE.THRESHOLD)
    {
      # Remove possible training chems from the analysis:
      level1tab[this.row,"Human.Clint.pred"] <-NA
      level1tab[this.row,"Human.Clint.AbsFE"] <-NA
      level1tab[this.row,"Human.Clint.FE"] <-NA
      print(paste("Precise prediction for Human.Clint.",this.qspr,sep=""))
      direct.retrieval.table <- rbind(direct.retrieval.table,
        data.frame(QSPR=this.qspr,
                   DTXSID = this.dtxsid,
                   Property = "Clint",
                   AbsFE = clint))
#      CvT.chems[CvT.chems$DTXSID == this.dtxsid,
#                paste("Human.Clint.",this.qspr,sep="")] <- NA                            
    }
  }
  fup <- level1tab[this.row,"Human.fup.AbsFE"]
  if (!is.na(fup))
  {
    if (fup < TOOCLOSE.THRESHOLD)
    {
      # Remove possible training chems from the analysis:
      level1tab[this.row,"Human.Fup.pred"] <-NA
      level1tab[this.row,"Human.fup.AbsFE"] <-NA
      level1tab[this.row,"Human.fup.FE"] <-NA
      print(paste("Precise prediction for Human.Fup.",this.qspr,sep=""))
      direct.retrieval.table <- rbind(direct.retrieval.table,
        data.frame(QSPR=this.qspr,
                   DTXSID = this.dtxsid,
                   Property = "Fup",
                   AbsFE = fup))
     # CvT.chems[CvT.chems$DTXSID == this.dtxsid,
     #            paste("Human.Fup.",this.qspr,sep="")] <- NA     
    }
  }
}
```

# Initialize training set supplemental table:
```{r load_training_sets}
dawson.fup <- read.csv("training_sets/Dawson-2021-fup.csv")
dawson.clint <- read.csv("training_sets/Dawson-2021-clint.csv")
pradeep.fup <- read.csv("training_sets/Pradeep-2020-fup.csv")
pradeep.clint <- read.csv("training_sets/Pradeep-2020-clint.csv")
opera.fup <- read.csv("training_sets/FU_QR.csv")
opera.clint <- read.csv("training_sets/Clint_QR.csv")
papa.hl <- read.csv("training_sets/Papa-2018-HL.txt",sep="\t")
```

# Create supplemental table listing which evaluation chemicals are in the training sets for which QSPRS
```{r training_set_sup_table, eval=TRUE}
training.set.table <- CvT.chems[,c("DTXSID",
  "Rat.Funbound.plasma",      
  "Human.Clint.ADMET",                            
"Human.Fup.ADMET",                               
"Human.Clint.Dawson",                           
"Human.Fup.Dawson",                              
"Human.Clint.Pradeep",                          
"Human.Fup.Pradeep",                             
"Human.Clint.OPERA",                            
"Human.Fup.OPERA",
"Human.Clint.IVBP")]
training.set.table[,2:dim(training.set.table)[2]] <- ""
training.set.table[,"Human.HL.QSAR-INS"] <- ""

for (this.dtxsid in CvT.chems$DTXSID)
{
  this.cas <- CvT.chems[CvT.chems$DTXSID==this.dtxsid,"CASRN"]
  # Dawson Fup:
  if (this.dtxsid %in% dawson.fup$DTXSID)
  {
    this.row <- level1tab$QSPR == "Dawson" & level1tab$DTXSID == this.dtxsid
    level1tab[this.row,"Human.Fup.pred"] <-NA
    level1tab[this.row,"Human.fup.AbsFE"] <-NA
    level1tab[this.row,"Human.fup.FE"] <-NA
    training.set.table[training.set.table$DTXSID==this.dtxsid,
                       "Human.Fup.Dawson"] <- "Training Set"
  }
  # Pradeep Fup:
  if (this.cas %in% pradeep.fup$CASRN)
  {
    this.row <- level1tab$QSPR == "Pradeep" & level1tab$DTXSID == this.dtxsid
    level1tab[this.row,"Human.Fup.pred"] <-NA
    level1tab[this.row,"Human.fup.AbsFE"] <-NA
    level1tab[this.row,"Human.fup.FE"] <-NA
    training.set.table[training.set.table$DTXSID==this.dtxsid,
                       "Human.Fup.Pradeep"] <- "Training Set"
  }  
  # OPERA Fup:
  if (this.cas %in% opera.fup$CASRN |
      this.dtxsid %in% opera.fup$DTXSID)
  {
    this.row <- level1tab$QSPR == "OPERA" & level1tab$DTXSID == this.dtxsid
    level1tab[this.row,"Human.Fup.pred"] <-NA
    level1tab[this.row,"Human.fup.AbsFE"] <-NA
    level1tab[this.row,"Human.fup.FE"] <-NA
    training.set.table[training.set.table$DTXSID==this.dtxsid,
                       "Human.Fup.OPERA"] <- "Training Set"
  }
  # Dawson Clint:
  if (this.dtxsid %in% dawson.clint$DTXSID)
  {
    this.row <- level1tab$QSPR == "Dawson" & level1tab$DTXSID == this.dtxsid
    level1tab[this.row,"Human.Clint.pred"] <-NA
    level1tab[this.row,"Human.Clint.AbsFE"] <-NA
    level1tab[this.row,"Human.Clint.FE"] <-NA
    training.set.table[training.set.table$DTXSID==this.dtxsid,
                       "Human.Clint.Dawson"] <- "Training Set"
  }
  # Pradeep Clint:
  if (this.cas %in% pradeep.clint$CASRN)
  {
    this.row <- level1tab$QSPR == "Pradeep" & level1tab$DTXSID == this.dtxsid
    level1tab[this.row,"Human.Clint.pred"] <-NA
    level1tab[this.row,"Human.Clint.AbsFE"] <-NA
    level1tab[this.row,"Human.Clint.FE"] <-NA
    training.set.table[training.set.table$DTXSID==this.dtxsid,
                       "Human.Clint.Pradeep"] <- "Training Set"
  }
  # OPERA Clint:
  if (this.cas %in% opera.clint$CASRN | 
      this.dtxsid %in% opera.clint$DTXSID)
  {
    this.row <- level1tab$QSPR == "OPERA" & level1tab$DTXSID == this.dtxsid
    level1tab[this.row,"Human.Clint.pred"] <-NA
    level1tab[this.row,"Human.Clint.AbsFE"] <-NA
    level1tab[this.row,"Human.Clint.FE"] <-NA
    training.set.table[training.set.table$DTXSID==this.dtxsid,
                       "Human.Clint.OPERA"] <- "Training Set"
  }
  # Papa HL:
  if (this.dtxsid %in% papa.hl$DTXSID)
  {
    training.set.table[training.set.table$DTXSID==this.dtxsid,
                       "Human.HL.QSAR-INS"] <- "Training Set"
  }  
}

sum(!is.na(level1tab.withtrainingset$Human.Fup.pred))
sum(!is.na(level1tab$Human.Fup.pred))
# Create a table with only predictions from the training set:
level1tab.trainingonly <- level1tab.withtrainingset
# Move back only those predictions removed from level1tab:
level1tab.trainingonly$Human.Fup.pred[!is.na(level1tab$Human.Fup.pred)] <- NA
level1tab.trainingonly$Human.Clint.pred[!is.na(level1tab$Human.Clint.pred)] <- NA

write.csv(training.set.table, row.names=FALSE,
          file="tables/SupTable-TrainingSetChems.txt")
```

# Make training set summary table for main text:
```{r training_set_summary_table}
hl.arnot <- read_excel("qsprs/TK_QSAR_evaluation_set_HumanQSARHLPredictions.xlsx")
hl.arnot <- subset(hl.arnot, administration_route_normalized=="iv")
qsar.ins.hl <- subset(hl.arnot,!is.na(QINS_Hum_HLT_Hour))
ifs.hl <- subset(hl.arnot,!is.na(IFS_Hum_HLT_Hour))

pharma <- read.csv("ccd_data/Chemical List ZINC15PHARMA-2024-09-09.csv")
pharma$DTXSID <- gsub("https://comptox.epa.gov/dashboard/chemical/details/",
                      "",
                      pharma$DTXSID)
train.set.sum.table <- data.frame(QSPR = c("ADMET",
                               "ADMET",
                               "Pradeep 2020",
                               "Pradeep 2020",
                               "Dawson 2021",
                               "Dawson 2021",
                               "OPERA",
                               "OPERA",
                               "IFS-QSAR",
                               "QSAR-INS",
                               "IVBP"),
                               Endpoint = c("Clint",
                               "fup",
                               "Clint",
                               "fup",
                               "Clint",
                               "fup",
                               "Clint",
                               "fup",
                               "halflife",
                               "halflife",
                               "Clint"),
                            Num.Chems = "a",
                            Fraction.Pharma = "b",
                            Num.Preds = 0,
                            Num.Eval.Chems = "b"
)
train.set.sum.table[train.set.sum.table$QSPR=="Pradeep 2020" &
                      train.set.sum.table$Endpoint == "fup",
                    "Num.Preds"] <- pred.counts["Pradeep","Fup"]
train.set.sum.table[train.set.sum.table$QSPR=="Pradeep 2020" &
                      train.set.sum.table$Endpoint == "Clint",
                    "Num.Preds"] <- pred.counts["Pradeep","Clint"]
train.set.sum.table[train.set.sum.table$QSPR=="Dawson 2021" &
                      train.set.sum.table$Endpoint == "fup",
                    "Num.Preds"] <- pred.counts["Dawson","Fup"]
train.set.sum.table[train.set.sum.table$QSPR=="Dawson 2021" &
                      train.set.sum.table$Endpoint == "Clint",
                    "Num.Preds"] <- pred.counts["Dawson","Clint"]
train.set.sum.table[train.set.sum.table$QSPR=="ADMET" &
                      train.set.sum.table$Endpoint == "fup",
                    "Num.Preds"] <- pred.counts["ADMET","Fup"]
train.set.sum.table[train.set.sum.table$QSPR=="ADMET" &
                      train.set.sum.table$Endpoint == "Clint",
                    "Num.Preds"] <- pred.counts["ADMET","Clint"]
train.set.sum.table[train.set.sum.table$QSPR=="OPERA" &
                      train.set.sum.table$Endpoint == "fup",
                    "Num.Preds"] <- pred.counts["OPERA","Fup"]
train.set.sum.table[train.set.sum.table$QSPR=="OPERA" &
                      train.set.sum.table$Endpoint == "Clint",
                    "Num.Preds"] <- pred.counts["OPERA","Clint"]
train.set.sum.table[train.set.sum.table$QSPR=="IVBP" &
                      train.set.sum.table$Endpoint == "Clint",
                    "Num.Preds"] <- pred.counts["IVBP","Clint"]
train.set.sum.table[train.set.sum.table$QSPR=="IFS-QSAR", "Num.Preds"] <-
  dim(ifs.hl)[1]
train.set.sum.table[train.set.sum.table$QSPR=="QSAR-INS", "Num.Preds"] <-
  dim(qsar.ins.hl)[1]

# PRadeep fup:
train.set.sum.table[train.set.sum.table$QSPR=="Pradeep 2020" &
                      train.set.sum.table$Endpoint == "fup","Num.Chems"] <-
  dim(pradeep.fup)[1]
train.set.sum.table[train.set.sum.table$QSPR=="Pradeep 2020" &
                      train.set.sum.table$Endpoint == "fup","Fraction.Pharma"] <-
  signif(sum(pradeep.fup$CASRN %in% pharma$CASRN)/dim(pradeep.fup)[1], 2)
train.set.sum.table[train.set.sum.table$QSPR=="Pradeep 2020" &
                      train.set.sum.table$Endpoint == "fup","Num.Eval.Chems"] <-
  sum(training.set.table$Human.Fup.Pradeep=="Training Set")
# Pradeep clint:
train.set.sum.table[train.set.sum.table$QSPR=="Pradeep 2020"&
                      train.set.sum.table$Endpoint == "Clint","Num.Chems"] <-
  dim(pradeep.clint)[1]
train.set.sum.table[train.set.sum.table$QSPR=="Pradeep 2020" &
                      train.set.sum.table$Endpoint == "Clint","Fraction.Pharma"] <-
  signif(sum(pradeep.clint$CASRN %in% pharma$CASRN)/dim(pradeep.clint)[1], 2)
train.set.sum.table[train.set.sum.table$QSPR=="Pradeep 2020"&
                      train.set.sum.table$Endpoint == "Clint","Num.Eval.Chems"] <-
  sum(training.set.table$Human.Clint.Pradeep=="Training Set")
# Dawson fup:
train.set.sum.table[train.set.sum.table$QSPR=="Dawson 2021" &
                      train.set.sum.table$Endpoint == "fup","Num.Chems"] <-
  dim(dawson.fup)[1]
train.set.sum.table[train.set.sum.table$QSPR=="Dawson 2021" &
                      train.set.sum.table$Endpoint == "fup","Fraction.Pharma"] <-
  signif(sum(dawson.fup$DTXSID %in% pharma$DTXSID)/dim(dawson.fup)[1], 2)
train.set.sum.table[train.set.sum.table$QSPR=="Dawson 2021" &
                      train.set.sum.table$Endpoint == "fup","Num.Eval.Chems"] <-
  sum(training.set.table$Human.Fup.Dawson =="Training Set")
# Dawson clint:
train.set.sum.table[train.set.sum.table$QSPR=="Dawson 2021"&
                      train.set.sum.table$Endpoint == "Clint","Num.Chems"] <-
  dim(dawson.clint)[1]
train.set.sum.table[train.set.sum.table$QSPR=="Dawson 2021" &
                      train.set.sum.table$Endpoint == "Clint","Fraction.Pharma"] <-
  signif(sum(dawson.clint$DTXSID %in% pharma$DTXSID)/dim(dawson.clint)[1], 2)
train.set.sum.table[train.set.sum.table$QSPR=="Dawson 2021"&
                      train.set.sum.table$Endpoint == "Clint","Num.Eval.Chems"] <-
  sum(training.set.table$Human.Clint.Dawson=="Training Set")
# OPERA fup:
train.set.sum.table[train.set.sum.table$QSPR=="OPERA" &
                      train.set.sum.table$Endpoint == "fup","Num.Chems"] <-
  dim(opera.fup)[1]
train.set.sum.table[train.set.sum.table$QSPR=="OPERA" &
                      train.set.sum.table$Endpoint == "fup","Fraction.Pharma"] <-
  signif(sum(opera.fup$CASRN %in% pharma$CASRN)/dim(opera.fup)[1], 2)
train.set.sum.table[train.set.sum.table$QSPR=="OPERA" &
                      train.set.sum.table$Endpoint == "fup","Num.Eval.Chems"] <-
  sum(training.set.table$Human.Fup.OPERA == "Training Set")
# OPERA clint:
train.set.sum.table[train.set.sum.table$QSPR=="OPERA" &
                      train.set.sum.table$Endpoint == "Clint","Num.Chems"] <-
  dim(opera.clint)[1]
train.set.sum.table[train.set.sum.table$QSPR=="OPERA" &
                      train.set.sum.table$Endpoint == "Clint","Fraction.Pharma"] <-
  signif(sum(opera.clint$CASRN %in% pharma$CASRN)/dim(opera.clint)[1], 2)
train.set.sum.table[train.set.sum.table$QSPR=="OPERA"&
                      train.set.sum.table$Endpoint == "Clint","Num.Eval.Chems"] <-
  sum(training.set.table$Human.Clint.OPERA == "Training Set")
# ADMET
train.set.sum.table[train.set.sum.table$QSPR=="ADMET",
                    "Num.Eval.Chems"] <- "a"
train.set.sum.table[train.set.sum.table$QSPR=="ADMET",
                    "Fraction.Pharma"] <- 1
# QSAR-INS:
train.set.sum.table[train.set.sum.table$QSPR=="QSAR-INS","Num.Chems"] <-
  dim(papa.hl)[1]
train.set.sum.table[train.set.sum.table$QSPR=="QSAR-INS","Fraction.Pharma"] <-
  signif(sum(papa.hl$DTXSID %in% pharma$DTXSID)/dim(papa.hl)[1], 2)
train.set.sum.table[train.set.sum.table$QSPR=="QSAR-INS","Num.Eval.Chems"] <-
  sum(training.set.table$"Human.HL.QSAR-INS" == "Training Set")
# IFS-QSAR:
train.set.sum.table[train.set.sum.table$QSPR=="IFS-QSAR","Num.Chems"] <-
  "b"
# IVBP:
train.set.sum.table[train.set.sum.table$QSPR=="IVBP","Num.Chems"] <-
  "b"

kable(train.set.sum.table)
write.csv(train.set.sum.table, row.names=FALSE,
          file=paste("tables/Table",
          PREV.TABLES+1,
          "-TrainingSetSummary.txt",
          sep=""))
cat("Num.Chems = Number of Chemicals in Training Set, Fraction.Pharma is fraction of Training Set Chemcials that are Pharmaceuticals, Num.Preds = OVerall number of Evaluation Chemicals with Predictions Inside QSPR Domain of Applicability, Num.Eval.Chems = Number of Evaluation Chemicals In QSPR Training Set\n")
cat("a: The training set is proprietary, consisting of pharmaceutical data.\n")
cat("b: The training set, while public, is either not machine-readable or the chemical identities cannot be cross-referenced.\n")
```

```{r compare lowerror_with_trainingset}
dim(direct.retrieval.table)
# Loop over each QSPR suspected of making a direct retrieval:
for (this.qspr in unique(direct.retrieval.table$QSPR))
{
  this.subset1 <- subset(direct.retrieval.table, QSPR==this.qspr)
  for (this.property in unique(this.subset1$Property))
# check to see if we have a training set fo this QSPR:
    if (any(training.set.table[, paste("Human.",
                                       this.property,
                                       ".",
                                       this.qspr,
                                       sep="")] ==
          "Training Set"))
    {
      this.subset2 <- subset(this.subset1, Property == this.property)
      for (this.chem in unique(this.subset2$DTXSID))
      # Remove from suspected direct retrievals if not in training set:
        if (training.set.table[training.set.table$DTXSID==this.chem, 
                               paste("Human.",
                                     this.property,
                                     ".",
                                     this.qspr,
                                     sep="")] !=
          "Training Set")
        {
          direct.retrieval.table <- subset(direct.retrieval.table, !(QSPR == this.qspr &
                                                                   Property == this.property &
                                                                   DTXSID == this.chem))
        }
    }
}
dim(direct.retrieval.table)
kable(direct.retrieval.table)
write.csv(direct.retrieval.table, row.names=FALSE,
          file=paste("tables/SupTable",
          PREV.SUP.TABLES + 5,
          "-PossibleDirectRetrievals.txt",
          sep=""))
```

# We don't want to penalize good predictions, so only remove suspected direct 
# retrievals from level 2/3 if:
# 1) low FE and known to be in training set
# 2) low FE and no training set available
```{r remove_direct_retrievals}
sum(!is.na(CvT.chems))
for(this.row in 1:dim(direct.retrieval.table)[1])
{
  this.chem <- direct.retrieval.table[this.row,"DTXSID"]
  this.property <- direct.retrieval.table[this.row,"Property"]
  this.qspr <- direct.retrieval.table[this.row,"QSPR"]
  print(paste(this.qspr,this.property))
  print(CvT.chems[CvT.chems$DTXSID==this.chem, 
                  paste("Human",this.property,this.qspr,sep=".")])
  CvT.chems[CvT.chems$DTXSID==this.chem, 
            paste("Human",this.property,this.qspr,sep=".")] <- NA 
  print(CvT.chems[CvT.chems$DTXSID==this.chem, 
                  paste("Human",this.property,this.qspr,sep=".")])
  }
sum(!is.na(CvT.chems))
```
Heatmap of the Data Set:
```{r make_heatmap, eval = TRUE}
  CvT.chems.scale <- CvT.chems[,c(
    "DTXSID",                                       
 "PREFERRED_NAME",                               
 "CASRN"  ,                                      
 "AVERAGE_MASS",                                 
 "BOILING_POINT_DEGC_OPERA_PRED" ,               
 "HENRYS_LAW_ATM-M3/MOLE_OPERA_PRED",            
 "OCTANOL_AIR_PARTITION_COEFF_LOGKOA_OPERA_PRED",
 "OCTANOL_WATER_PARTITION_LOGP_OPERA_PRED" ,     
 "MELTING_POINT_DEGC_OPERA_PRED",                
"VAPOR_PRESSURE_MMHG_OPERA_PRED",               
"WATER_SOLUBILITY_MOL/L_OPERA_PRED" ,           
 "Thalf.fit",    
 "Human.Clint.httk"  ,                           
 "Human.Fup.httk",                               
 "Human.Clint.ADMET",                            
 "Human.Fup.ADMET",                              
 "Human.Clint.Dawson",                           
 "Human.Fup.Dawson",                             
 "Human.Clint.Pradeep",                          
 "Human.Fup.Pradeep",                            
 "Human.Clint.OPERA" ,                           
 "Human.Fup.OPERA",                              
 "Human.Clint.IVBP" 
)]
  colnames(CvT.chems.scale)[colnames(CvT.chems.scale) == "AVERAGE_MASS"] <- "Molecular Weight"
  colnames(CvT.chems.scale)[colnames(CvT.chems.scale) == "BOILING_POINT_DEGC_OPERA_PRED"] <- "Boiling Point"
  colnames(CvT.chems.scale)[colnames(CvT.chems.scale) == "HENRYS_LAW_ATM-M3/MOLE_OPERA_PRED"] <- "Henry's Law"
  colnames(CvT.chems.scale)[colnames(CvT.chems.scale) == "OCTANOL_AIR_PARTITION_COEFF_LOGKOA_OPERA_PRED"] <- "Octanol:Air"
  colnames(CvT.chems.scale)[colnames(CvT.chems.scale) == "OCTANOL_WATER_PARTITION_LOGP_OPERA_PRED"] <- "Octanol:Water"
  colnames(CvT.chems.scale)[colnames(CvT.chems.scale) == "MELTING_POINT_DEGC_OPERA_PRED"] <- "Melting Point"
  colnames(CvT.chems.scale)[colnames(CvT.chems.scale) == "VAPOR_PRESSURE_MMHG_OPERA_PRED"] <- "Vapor Pressure"
  colnames(CvT.chems.scale)[colnames(CvT.chems.scale) == "WATER_SOLUBILITY_MOL/L_OPERA_PRED"] <- "Water Solubility"
  rownames(CvT.chems.scale) <- CvT.chems.scale$PREFERRED_NAME 
last.col <- dim(CvT.chems.scale)[2]
# Make sure everything is numeric:
  for (this.col in 4:last.col) CvT.chems.scale[,this.col] <- 
    as.numeric(CvT.chems.scale[,this.col])
clint.col <- which(colnames(CvT.chems.scale) == "Human.Clint.httk")
fup.col <- which(colnames(CvT.chems.scale) == "Human.Fup.httk")
httk.start <- min(clint.col,fup.col) 
# Scale and center
  for (this.col in 4:(httk.start-1)) 
    CvT.chems.scale[,this.col] <- 
    (CvT.chems.scale[,this.col] - mean(CvT.chems.scale[,this.col],na.rm=TRUE)) / 
    sd(CvT.chems.scale[,this.col],na.rm=TRUE)
# scale and center all predictions by in vitro:
clint.mean <- mean(CvT.chems.scale[,clint.col], na.rm=TRUE)
fup.mean <- mean(CvT.chems.scale[,fup.col], na.rm=TRUE)
clint.sd <- sd(CvT.chems.scale[,clint.col], na.rm=TRUE)
fup.sd <- sd(CvT.chems.scale[,fup.col], na.rm=TRUE)
for (this.col in seq(clint.col,last.col,2)) CvT.chems.scale[,this.col] <- 
    (CvT.chems.scale[,this.col] - clint.mean) / clint.sd
for (this.col in seq(fup.col,last.col,2)) CvT.chems.scale[,this.col] <- 
    (CvT.chems.scale[,this.col] - fup.mean) / fup.sd

    mypalette<-brewer.pal(11,"RdYlBu")
  heatmap.2(as.matrix(CvT.chems.scale[,4:(dim(CvT.chems.scale)[2])]),
    lwid=c(0.4,1),
    lhei=c(0.4,1),
    margins=c(15,1),
    labRow = FALSE,
    cexCol=1,
    trace="none",
    col=mypalette)
  png(paste("figs/Fig3-physchemandpredictors-heatmap-",
           output.prefix,
           ".tiff",sep=""),
          width=800, height=750)
  heatmap.2(as.matrix(CvT.chems.scale[,4:(dim(CvT.chems.scale)[2])]),
    lwid=c(0.4,1),
    lhei=c(0.4,1),
    margins=c(15,1),
    labRow = FALSE,
    cexCol=1.5,
    trace="none",
 #   dendrogram = "none",
    col=mypalette)
  dev.off()
  
cat("Figure Caption\n")
cat("Each row corresponds to one of the",
    dim(CvT.chems.scale)[1],
    "chemicals.")
```

```{r text_for_paper}
cat("For the Dawson et al. (2021) Clint training set, 
    dim(subset(dawson.clint)
    ")
cat("Results: QSPR Predictions\n")
cat(paste("A total of",
    sum(training.set.table[,2:9]!=""),
    "QSPR predictions were removed from the Level 1 evaluation since they were",
    "in the QSPR training set data (see Supplement Materials Table",
    "SupTable-TrainingSetChems.txt).\n"))
cat("\n")
cat(paste("Table 4 summarizes the training sets for each QSPR approach and predicted",
    "endpoint. Training sets were evaluated for relative fraction of pharmaceutical",
    "chemicals and number of CvT evaluation chemicals included.\n"))
cat("\n")
cat("In Table 4 we indicate the number of evaluation chemicals with predictions inside each QSPRs domain of applicability. In table 4 we also identify how many of the evaluation chemicals were included in the various training sets. Since many of the evaluation chemicals were in the various training sets, we still included QSPR predictions in the CvT evaluations when they not appear to be direct retrievals of a training set value (as in a nearest-neighbor algorithm identifying the compound itself). We believe that there is value to evaluating the predictions made as long as the method of prediction is the same as what would be used for a chemical without a measured value.")
cat("\n")
#cat(paste("We removed a total of",
#          dim(direct.retrieval.table)[1],
#          "predictions from the level 2 and 3 evaluations for being too similar (within one percent) of the measured value (see Supplement Materials Table SupTable-PossibleDirectRetrievals.txt).\n"))
#cat("\n")
cat("Results: Level 1 Analysis\n")
cat("\n")
```

# Count the number of predictions
```{r number_predictions_after_training_removed, eval = TRUE}
pred.counts2 <- data.frame()
for (this.qspr in unique(level1tab$QSPR))
{
  pred.counts2[this.qspr,"Clint"] <-
    sum(!is.na(subset(level1tab, QSPR==this.qspr)$Human.Clint.pred))
  pred.counts2[this.qspr,"Fup"] <-
    sum(!is.na(subset(level1tab, QSPR==this.qspr)$Human.Fup.pred))
}

kable(pred.counts2)

write.csv(pred.counts2,
          file="tables/SupTable-QSPRPredCountsPostTrainingRemoval.txt")
```

```{r fold_error_differences, eval = TRUE}
ks.tests.clint <- data.frame()
ks.tests.fup <- data.frame()
FE.table <- data.frame()
for (this.qspr1 in unique(as.character(level1tab$QSPR)))
{
  this.subset <-subset(level1tab,QSPR==this.qspr1)
  FE.table[this.qspr1,"Num.Clint.Compared"] <-
    sum(!is.na(this.subset$Human.Clint.AbsFE))
  FE.table[this.qspr1,"Median.Clint.AbsFE"] <- 
    median(this.subset$Human.Clint.AbsFE,na.rm=TRUE)
  FE.table[this.qspr1,"Median.Clint.FE"] <- 
    median(this.subset$Human.Clint.FE,na.rm=TRUE)
  FE.table[this.qspr1,"Min.Clint.FE"] <- 
    min(this.subset$Human.Clint.FE,na.rm=TRUE)
  FE.table[this.qspr1,"Max.Clint.FE"] <- 
    max(this.subset$Human.Clint.FE,na.rm=TRUE)
  FE.table[this.qspr1,"Num.fup.Compared"] <-
    sum(!is.na(this.subset$Human.fup.AbsFE))
  FE.table[this.qspr1,"Median.fup.AbsFE"] <- 
    median(this.subset$Human.fup.AbsFE,na.rm=TRUE)
  FE.table[this.qspr1,"Median.fup.FE"] <- 
    median(this.subset$Human.fup.FE,na.rm=TRUE)
  FE.table[this.qspr1,"Min.fup.FE"] <- 
    min(this.subset$Human.fup.FE,na.rm=TRUE)
  FE.table[this.qspr1,"Max.fup.FE"] <- 
    max(this.subset$Human.fup.FE,na.rm=TRUE)
}
for (this.qspr1 in unique(as.character(level1tab$QSPR)))
{
  this.subset <-subset(level1tab,QSPR==this.qspr1)
  for (this.qspr2 in unique(as.character(level1tab$QSPR)))
  {
    set1 <- this.subset$Human.Clint.FE
    set2 <- subset(level1tab,QSPR==this.qspr2)$Human.Clint.FE
    print(this.qspr2)
    print(set2)
    if (any(!is.na(set1)) & any(!is.na(set2))) ks.tests.clint[this.qspr1,this.qspr2] <- suppressWarnings(
      ks.test(set1,set2)$p.value)
    set1 <- this.subset$Human.fup.FE
    set2 <- subset(level1tab,QSPR==this.qspr2)$Human.fup.FE
    if (any(!is.na(set1)) & any(!is.na(set2))) ks.tests.fup[this.qspr1,this.qspr2] <- suppressWarnings(
      ks.test(set1,set2)$p.value)
  }
}

FE.table <- apply(FE.table, 2, function(x) signif(x,3))
ks.tests.clint <- apply(ks.tests.clint,2,function(x) signif(x,3))
ks.tests.fup <- apply(ks.tests.fup, 2, function(x) signif(x,3))
kable(FE.table)
kable(ks.tests.clint)
kable(ks.tests.fup)
write.csv(FE.table, file=paste(
  "tables/Table",
  PREV.TABLES + 3, # 6
  "-Level1FoldError.txt",
  sep=""))
write.csv(ks.tests.clint, file=paste(
  "tables/SupTable",
  PREV.SUP.TABLES + 6, #6,
  "-Level1KSCorClint.txt",
  sep=""))
write.csv(ks.tests.fup, file=paste(
  "tables/SupTable",
  PREV.SUP.TABLES + 7, #7
  "-Level1KSCorFup.txt",
  sep=""))
```

Calculate RPE:     
```{r prediction_table, eval = TRUE}
level1tab[,"Human.Clint.RPE"] <- 
  (as.numeric(level1tab[,"Human.Clint.pred"]) - 
  as.numeric(level1tab[,"Human.Clint.httk"])) /
  as.numeric(level1tab[,"Human.Clint.httk"])
level1tab[,"Human.Fup.RPE"] <- 
  (as.numeric(level1tab[,"Human.Fup.pred"]) - 
  as.numeric(level1tab[,"Human.Fup.httk"])) /
  as.numeric(level1tab[,"Human.Fup.httk"])
```

```{r make_historams, eval=FALSE}
hist(subset(level1tab,QSPR=="Dawson")$Human.Clint.RPE,
     main="Dawson",xlab="Clint RPE")
hist(subset(level1tab,QSPR=="Pradeep")$Human.Clint.RPE,
     main="Pradeep",xlab="Clint RPE")
hist(subset(level1tab,QSPR=="ADMET")$Human.Clint.RPE,
     main="ADMET",xlab="Clint RPE")
hist(subset(level1tab,QSPR=="OPERA")$Human.Clint.RPE,
     main="OPERA",xlab="Clint RPE")

hist(subset(level1tab,QSPR=="Dawson")$Human.Fup.RPE,
     main="Dawson",xlab="Fup RPE")
hist(subset(level1tab,QSPR=="Pradeep")$Human.Fup.RPE,
     main="Pradeep",xlab="Fup RPE")
hist(subset(level1tab,QSPR=="ADMET")$Human.Fup.RPE,
     main="ADMET",xlab="Fup RPE")
hist(subset(level1tab,QSPR=="OPERA")$Human.Fup.RPE,
     main="OPERA",xlab="Fup RPE")
```

Check distribution of RPE for Clint:
```{r clint_rpe_hist, eval = TRUE}
hist(subset(level1tab,QSPR=="OPERA")$Human.Clint.RPE,main="OPERA",xlab="Clint RPE")
```

Check distribution of RPE for Fup:
```{r fup_rpe_hist, eval = TRUE}
hist(subset(level1tab,QSPR=="OPERA")$Human.Fup.RPE,main="OPERA",xlab="Fup RPE")
```

Make Level1 predictions vs. observed plot for Clint:
```{r clint_scatter, eval = TRUE}
FigLev1a <- ggplot(data=level1tab) +
  geom_point(size=3,alpha=0.5,
             aes(x=Human.Clint.pred+10^-4,
                 y=Human.Clint.httk+10^-4,
                 shape=QSPR,
                 fill=QSPR,
                 color=QSPR))+
  scale_shape_manual(values = ggshapes)+
  scale_color_manual(values = ggcolors)+
  scale_fill_manual(values = ggcolors)+
  scale_x_log10(label=scientific_10) +
  scale_y_log10(label=scientific_10)+
  geom_abline(intercept = log10(10^(1/2)), 
              slope = 1,
              linetype="dashed", 
              colour="lightBlue") + 
  geom_abline(intercept = 0, 
              slope = 1,
              linetype="solid", 
              colour="Grey") + 
  geom_abline(intercept = log10(10^(-1/2)), 
              slope = 1
              ,linetype="dashed", 
              colour="lightBlue") + 
  xlab(bquote('Predicted'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
  ylab(bquote('Obs.'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
  theme_bw()+
  theme( text  = element_text(size=16))
print(FigLev1a)
#ggsave(paste("figs/Fig3-Lev1a-Clint-obsvspred",output.prefix,".tiff",sep=""), 
#       width=6, height=4, dpi=300)
```

```{r clint_scatter_train, eval = TRUE}
FigLev1apanel2 <- ggplot(data=level1tab.trainingonly) +
  geom_point(size=3,alpha=0.5,
             aes(x=Human.Clint.pred+10^-4,
                 y=Human.Clint.httk+10^-4,
                 shape=QSPR,
                 fill=QSPR,
                 color=QSPR))+
  scale_shape_manual(values = ggshapes)+
  scale_color_manual(values = ggcolors)+
  scale_fill_manual(values = ggcolors)+
  scale_x_log10(label=scientific_10) +
  scale_y_log10(label=scientific_10)+
  geom_abline(intercept = log10(10^(1/2)), 
              slope = 1,
              linetype="dashed", 
              colour="lightBlue") + 
  geom_abline(intercept = 0, 
              slope = 1,
              linetype="solid", 
              colour="Grey") + 
  geom_abline(intercept = log10(10^(-1/2)), 
              slope = 1
              ,linetype="dashed", 
              colour="lightBlue") + 
  xlab(bquote('Predicted'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
  ylab(bquote('Obs.'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
  theme_bw()+
  theme( text  = element_text(size=16))
print(FigLev1apanel2)
ggarrange(FigLev1a,FigLev1apanel2,labels=c("A","B"),common.legend=TRUE)
ggsave(paste("figs/Fig4-Clint-obsvspred",output.prefix,".tiff",sep=""), 
       width=8, height=4.5, dpi=300)
```

## Make Level1 predictions vs. observed plot for Clint (faceted):
```{r clint_rpe_scatter, eval = TRUE}

## Tiff image for manuscript (facet to see the individual predictions over Clint value)
FigLev1a_facet <- ggplot(data=level1tab) +
  geom_point(size=2,aes(x=Human.Clint.pred+10^-1,
                        y=Human.Clint.httk+10^-1,
                        shape=QSPR,fill=QSPR,color=QSPR))+
  scale_shape_manual(values = ggshapes)+
  scale_color_manual(values = ggcolors)+
  scale_fill_manual(values = ggcolors)+
  scale_x_log10(breaks=c(1,10^2),label=scientific_10,limits=c(30^-1,3000)) +
  #scale_y_log10(label=scientific_10)+
  scale_y_log10(breaks=c(10^-1,1,10,10^2),
                label=scientific_10,limits = c(30^-1, 3000))+
  geom_abline(intercept = 0, 
              slope = 1,linetype="solid", colour="black",linewidth=0.2) +
  #geom_abline(intercept = log10(3), slope = 1,linetype="dotted", colour="gray") +
  #geom_abline(intercept = -log10(3), slope = 1,linetype="dotted", colour="gray") +
  geom_abline(intercept = 1, 
              slope = 1,linetype="dashed", colour="gray66",linewidth=0.3) +
  geom_abline(intercept = -1, 
              slope = 1,linetype="dashed", colour="gray66",linewidth=0.3) +
  xlab(bquote('Predicted'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
  ylab(bquote('Observed'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
  theme_bw()+
  facet_wrap(~QSPR)+
  theme( text  = element_text(size=20),
         legend.position = "none",
         axis.title = element_text(size=20),
         axis.text.x = element_text(size=14))

print(FigLev1a_facet)
ggsave(paste("figs/SupFigLev1a-Clint-obsvpred-facet-",output.prefix,".tiff",sep=""), 
       width=6, height=5, dpi=300)
```

Make Level1 RPE box and whisker plot for Clint:
```{r clint_rpe_boxwhisker, eval = TRUE}
FigLev1b <- ggplot(data=level1tab, aes(x=QSPR, y=Human.Clint.RPE)) + 
  geom_boxplot(outlier.colour="red",    
    outlier.size=2,
    outlier.alpha=0.1)+
  xlab("QSPR") +
  ylab(bquote("Relative Prediction Error in"~Cl[int]))+
  scale_y_log10(breaks=c(10^-2,10^-1,1,3,10,10^2,10^3),label=scientific_10)+
  theme_bw()+
  theme( text  = element_text(size=20))
  print(FigLev1b)  
```

## calculate some statistics
```{r calc_AbsFE_RMSE, eval=TRUE}
Human.Clint.stats.table <- Human.fup.stats.table <- data.frame()
level1tab$Human.Clint.pred <- as.numeric(level1tab$Human.Clint.pred)
level1tab$Human.Clint.httk <- as.numeric(level1tab$Human.Clint.httk)
level1tab$Human.Fup.pred <- as.numeric(level1tab$Human.Fup.pred)
level1tab$Human.Clint.AbsFE <- as.numeric(level1tab$Human.Clint.AbsFE)
level1tab$Human.fup.AbsFE <- as.numeric(level1tab$Human.fup.AbsFE)
for (this.qspr in unique(level1tab$QSPR))
  if (!(this.qspr %in% c("In Vitro")))
  {
#Absolute Average Fold Error (AAFE) :  10^((1/n)*sum(abs(FE)))  ### use this. It's good to see fold error
    Human.Clint.stats.table["AAFE",this.qspr] <- calc_AAFE(
        subset(level1tab, QSPR==this.qspr),
        AbsFE.col="Human.Clint.AbsFE",
        sigfig=2)                                
    Human.fup.stats.table["AAFE",this.qspr] <- calc_AAFE(
        subset(level1tab, QSPR==this.qspr),
        AbsFE.col="Human.fup.AbsFE",
        sigfig=2)                                
#RMSLE sqrt(mean(log10(Xpred+1)-log10(Xobs+1))^2)  ### use this
    Human.Clint.stats.table["RMSLE",this.qspr] <- calc_RMSLE(
        subset(level1tab, QSPR==this.qspr),
        pred.col="Human.Clint.pred",
        obs.col="Human.Clint.httk",
        sigfig=2,
# How low do we want the zeros to be in the log10 calculation? This makes them at least 10x lower than lowest non-zero prediciton.
        zeroval=sort(unique(subset(level1tab, QSPR==this.qspr)$Human.Clint.pred,na.rm=TRUE))[2]/10)                           
    Human.fup.stats.table["RMSLE",this.qspr] <- calc_RMSLE(
        subset(level1tab, QSPR==this.qspr),
        pred.col="Human.Fup.pred",
        obs.col="Human.Fup.httk",
        sigfig=2,
        zeroval=sort(unique(subset(level1tab, QSPR==this.qspr)$Human.Fup.pred,na.rm=TRUE))[2]/10)  
  }
kable(Human.Clint.stats.table)
kable(Human.fup.stats.table)
write.csv(Human.Clint.stats.table, file="tables/SupTable-ClintStats.txt")
write.csv(Human.fup.stats.table, file="tables/SupTable-FupStats.txt")
```

#### add AAFE & RMSLE to the table
```{r clint_rpe_boxwhisker_stats, eval = TRUE}
# Make sure the QSPRs are displayed in the same order as columns in stats table:
#level1tab$QSPR <- factor(level1tab$QSPR,
#                             levels=colnames(Human.Clint.stats.table))
FigLev1b.texty <- -2
FigLev1b <- ggplot(data=level1tab, aes(x=QSPR, y=Human.Clint.RPE)) + 
  geom_boxplot(lwd=.3,  #reduce the boxplot linewidth
               outlier.shape=NA)+
  coord_cartesian(ylim=c(-3,8))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  xlab("QSPR") +
  ylab(bquote("Relative Error in"~Cl[int]))+
  theme_bw()+
  theme( text  = element_text(size=20),
         legend.key.height=unit(.5,"line"),
         legend.text=element_text(size=7),
         legend.title = element_text(size=8))

FigLev1b <- FigLev1b + annotation_custom(tableGrob(rownames(Human.Clint.stats.table), 
                              theme = ttheme_minimal(base_size = 10)),
                              xmin=0,xmax=1.5,
                              ymin=(FigLev1b.texty-1),ymax=FigLev1b.texty)
for (i in 1:length(colnames(Human.Clint.stats.table)))
{
  FigLev1b <- FigLev1b + annotation_custom(
    tableGrob(Human.Clint.stats.table[,i],rows=NULL, 
              theme = ttheme_minimal(base_size = 14)),
    xmin=0,xmax=(2*i+0.3),
    ymin=(FigLev1b.texty-1),ymax=FigLev1b.texty)
}

print(FigLev1b) 
ggsave(paste("figs/SupFigLev1b-Clint-boxplot-wtable-",output.prefix,".tiff",sep=""), 
       width=6, height=4, dpi=300)
```

```{r fup_rpe_scatterall, eval = TRUE}

FigLev1c <- ggplot(data=subset(level1tab,!(QSPR %in% "IVBP"))) +
  geom_point(size=3,
             alpha=0.5,
             aes(x=Human.Fup.pred+10^-4,
                 y=Human.Fup.httk+10^-4,
                 shape=QSPR,fill=QSPR,color=QSPR))+
  scale_shape_manual(values = ggshapes)+
  scale_color_manual(values = ggcolors)+
  scale_fill_manual(values = ggcolors)+
  scale_x_log10(label=scientific_10) +
  scale_y_log10(label=scientific_10)+
  geom_abline(intercept = log10(10^(1/2)), 
              slope = 1,linetype="dashed", 
              colour="lightBlue") +
  geom_abline(intercept = 0, 
              slope = 1,
              linetype="solid", 
              colour="Grey") + 
  geom_abline(intercept = log10(10^(-1/2)), 
              slope = 1,linetype="dashed", 
              colour="lightBlue") + 
  xlab(bquote('Predicted'~f[up])) +
  ylab(bquote('Observed'~f[up])) +
  theme_bw()+
  theme( text  = element_text(size=20))
print(FigLev1c)
#ggsave(paste("figs/Fig4-Lev1c-Fup-obsvpred-",output.prefix,".tiff",sep=""), 
#       width=6, height=4, dpi=300)
```

```{r fup_rpe_scatterall_training, eval = TRUE}

FigLev1cpanel2 <- ggplot(data=subset(level1tab.trainingonly,!(QSPR %in% "IVBP"))) +
  geom_point(size=3,
             alpha=0.5,
             aes(x=Human.Fup.pred+10^-4,
                 y=Human.Fup.httk+10^-4,
                 shape=QSPR,fill=QSPR,color=QSPR))+
  scale_shape_manual(values = ggshapes)+
  scale_color_manual(values = ggcolors)+
  scale_fill_manual(values = ggcolors)+
  scale_x_log10(label=scientific_10) +
  scale_y_log10(label=scientific_10)+
  geom_abline(intercept = log10(10^(1/2)), 
              slope = 1,linetype="dashed", 
              colour="lightBlue") +
  geom_abline(intercept = 0, 
              slope = 1,
              linetype="solid", 
              colour="Grey") + 
  geom_abline(intercept = log10(10^(-1/2)), 
              slope = 1,linetype="dashed", 
              colour="lightBlue") + 
  xlab(bquote('Predicted'~f[up])) +
  ylab(bquote('Observed'~f[up])) +
  theme_bw()+
  theme( text  = element_text(size=20))
print(FigLev1cpanel2)
ggarrange(FigLev1c,FigLev1cpanel2,labels=c("A","B"),common.legend=TRUE)
ggsave(paste("figs/Fig5-Fup-obsvpred-twopanel",output.prefix,".tiff",sep=""), 
       width=8, height=4, dpi=300)
```

```{r fup_rpe_boxwhisker_faceted, eval = TRUE}

## faceted
FigLev1cfacet <- ggplot(data=subset(level1tab,!(QSPR %in% "IVBP"))) +
  geom_point(size=2,
             aes(x=Human.Fup.pred+10^-4,
                 y=Human.Fup.httk+10^-4,
                 shape=QSPR, 
                 fill=QSPR,
                 color=QSPR))+
  scale_x_log10(breaks=c(10^-8,10^-6,10^-4,10^-2,1),label=scientific_10)+
  scale_y_log10(breaks=c(10^-8,10^-6,10^-4,10^-2,1),label=scientific_10)+
  scale_shape_manual(values = ggshapes)+
  scale_color_manual(values = ggcolors)+
  scale_fill_manual(values = ggcolors)+
  geom_abline(intercept = 0, slope = 1,
              linetype="solid", colour="black", linewidth=0.2) +
  geom_abline(intercept = 1, slope = 1,
              linetype="dashed", colour="gray66", linewidth=0.3) +
  geom_abline(intercept = -1, slope = 1,
              linetype="dashed", colour="gray66", linewidth=0.3) +
  xlab(bquote('Predicted'~f[up])) +
  ylab(bquote('Observed'~f[up])) +
  facet_wrap(~QSPR)+
  theme_bw()+
  theme( text  = element_text(size=20),
         legend.position = "none",
         axis.title = element_text(size=20),
         axis.text.x = element_text(size=14))
print(FigLev1cfacet)
ggsave(paste("figs/SupFigLev1c-Fup-obsVpred-facet-",output.prefix,".tiff",sep=""), 
       width=6, height=4.5, dpi=300)
```

```{r fup_rpe_boxwhisker_stats, eval = TRUE}
FigLev1d <- ggplot(data=subset(level1tab,!(QSPR %in% "IVBP")), 
                   aes(x=QSPR, y=Human.Fup.RPE)) + 
  geom_boxplot(outlier.colour="red",    
    outlier.size=2,
    outlier.alpha=0.1)+
  xlab("QSPR") +
  ylab(bquote("Relative Prediction Error in"~f[up]))+
  scale_y_log10(breaks=c(10^-2,10^-1,1,3,10,10^2,10^3),label=scientific_10)+
  theme_bw()+
  theme( text  = element_text(size=20))
print(FigLev1d)  
ggsave(paste("figs/SupFigLev1d-Fup-RPE-",output.prefix,".tiff",sep=""), 
       width=6, height=4, dpi=300)
```

#### add AAFE & RMSLE to the table
```{r fup_rpe_boxwhisker_stats, eval = TRUE}

texty <- 3
FigLev1d <- ggplot(data=subset(level1tab,!(QSPR %in% "IVBP"))
                             , aes(x=QSPR, y=Human.Fup.RPE)) + 
  geom_boxplot(lwd=.3,  #reduce the boxplot linewidth
               outlier.shape=NA)+
 # coord_cartesian(ylim=c(-3,6))+ ### Pradeep NEW !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  coord_cartesian(ylim=c(-1.5,3))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  xlab("QSPR") +
  ylab(bquote("Relative Error in"~f[up]))+
  theme_bw()+
  theme( text  = element_text(size=20),
         legend.key.height=unit(.5,"line"),
         legend.text=element_text(size=7),
         legend.title = element_text(size=8))

FigLev1d <- FigLev1d + annotation_custom(tableGrob(rownames(Human.fup.stats.table), 
                              theme = ttheme_minimal(base_size = 14)),
                              xmin=0,xmax=1.5,
                              ymin=(texty-1),ymax=texty)
for (i in 1:length(colnames(Human.fup.stats.table)))
  if (!(colnames(Human.fup.stats.table)[i] %in% c("IVBP")))
{
  FigLev1d <- FigLev1d + annotation_custom(
    tableGrob(Human.Clint.stats.table[,i],rows=NULL, 
              theme = ttheme_minimal(base_size = 14)),
    xmin=0,xmax=(2*i+0.3),
    ymin=(texty-1),ymax=texty)
}      

print(FigLev1d) 
ggsave(paste("figs/SupFigLev1d-fup-boxplot-wtable-",output.prefix,".tiff",sep=""), 
       width=6, height=4, dpi=300)
```

```{r write_out_data, eval=TRUE}
save(training.set.table,
     direct.retrieval.table,
     file="data/trainingchems.RData")
save(CvT.chems,CvT.chems.scale,
     file="data/Cvt-chems-level1.RData")
```
```{r text_for_manuscript}
```