---
title: "TK QSAR Bakeoff"
author: "John Wambaugh and Nisha Sipes"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{TKQSAR Bakeoff}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
knitr::opts_chunk$set(collapse = TRUE, comment = '#>')
```
To use the code in this vignette, you'll first need to load a few packages (if you haven't already).
```{r load_packages, eval = TRUE}
# Clear the memory:
rm(list=ls()) 

library(readxl)
library(ggplot2)
library(httk)
library(scales)
library(gplots)
library(RColorBrewer)
library(DescTools)
library(gridExtra)
library(reshape2)
```
Load custom code 
```{r load_code, eval = TRUE}
setwd("C:/Users/jwambaug/git/tkqsars/")
source("clear_httk.R")
source("tkstats.R")

# Function for formating tick labels:
scientific_10 <- function(x) {                                  
  out <- gsub("1e", "10^", scientific_format()(x))              
  out <- gsub("\\+","",out)                                     
  out <- gsub("10\\^01","10",out)                               
  out <- parse(text=gsub("10\\^00","1",out))                    
}  
```

Set the time stamp:
```{r time_stamp, eval = TRUE}
# Time stamp:
output.prefix <- toupper(format(Sys.Date(),"%Y%b%d"))
```


Load the CvTdb in vivo data from Sayre et al. (2020):
```{r load_data, eval = TRUE}
series_res_set <- read.csv("cvt_query_for_john_27may2021.csv")
colnames(series_res_set)[colnames(series_res_set)=="species"] <- "Species"
colnames(series_res_set)[colnames(series_res_set)=="conc_medium_normalized"] <- "Media"
colnames(series_res_set)[colnames(series_res_set)=="conc"] <- "Value"
colnames(series_res_set)[colnames(series_res_set)=="time_hr"] <- "Time"
colnames(series_res_set)[colnames(series_res_set)=="dose_level_normalized"] <- "Dose"
colnames(series_res_set)[colnames(series_res_set)=="administration_route_normalized"] <- "Route"
colnames(series_res_set)[colnames(series_res_set)=="dsstox_casrn"] <- "CAS"
colnames(series_res_set)[colnames(series_res_set)=="dsstox_substance_id"] <- "DTXSID"
colnames(series_res_set)[colnames(series_res_set)=="analyte_name_original"] <- "Compound"
colnames(series_res_set)[colnames(series_res_set)=="fk_study_id"] <- "Source"


# A list of the chemcials in the evaluation:
# There are 101 chemicals with CvT data for which the collaborators have been asked
# to make predictions
eval.cas <- unique(series_res_set$CAS)
length(eval.cas)

# We have both human and rat:
series_res_set$Species <- tolower(series_res_set$Species)
unique(series_res_set$Species)
# We habe both blood and plasma:
series_res_set$Media <- tolower(series_res_set$Media)
unique(series_res_set$Media)

# Significant figures:
series_res_set$Time <- suppressWarnings(signif(
  as.numeric(series_res_set$Time),2))
series_res_set$Value <- suppressWarnings(signif(
  as.numeric(series_res_set$Value),4))

CvT.data <- series_res_set
CvT.chems <- unique(CvT.data$DTXSID)

CvT.data[,"Dose"] <- as.numeric(CvT.data[,"Dose"])

CvT.data <- subset(CvT.data,Time>0)
```
Calculate a limit of quantification (90% of lowest observation)
```{r calc_loq, eval = TRUE}
for (this.study in unique(CvT.data$Source))
{
  this.subset1 <- subset(CvT.data,Source==this.study)
  for (this.chem in unique(this.subset1$CAS))
  {
    this.subset2 <- subset(this.subset1,CAS==this.chem)
    for (this.media in unique(this.subset2$Media))
    {
      this.subset3 <- subset(this.subset2,Media==this.media & !is.na(Value))
      this.subset3 <- subset(this.subset3,Value>0)
      this.loq <- suppressWarnings(min(this.subset3$Value,na.rm=TRUE))
      this.loq <- this.loq*0.9
      CvT.data[
        CvT.data$Source==this.study & 
        CvT.data$CAS==this.chem & 
        CvT.data$Media==this.media,"calc_loq"] <- this.loq
    }
  }
}
CvT.data <- subset(CvT.data,!is.infinite(calc_loq))

```


```{r load_physchem, eval = TRUE}
CvT.chems <-read_excel("eval-chems3.xls")
for (this.col in 6:18) CvT.chems[,this.col] <- suppressWarnings(signif(
  as.numeric(unlist(CvT.chems[,this.col])),3))
CvT.chems <- CvT.chems[,c(
  "DTXSID",
  "PREFERRED_NAME",
  "CASRN",
  "AVERAGE_MASS",                                                    
  "BOILING_POINT_DEGC_OPERA_PRED",                                   
  "HENRYS_LAW_ATM-M3/MOLE_OPERA_PRED",
  "OCTANOL_AIR_PARTITION_COEFF_LOGKOA_OPERA_PRED",
  "OCTANOL_WATER_PARTITION_LOGP_OPERA_PRED",
  "MELTING_POINT_DEGC_OPERA_PRED",                                   
  "VAPOR_PRESSURE_MMHG_OPERA_PRED",
  "WATER_SOLUBILITY_MOL/L_OPERA_PRED"
  )]

```

Create a default table of in vitro measured values:
```{r default_table, eval = TRUE}

reset_httk()
httk.data <- subset(chem.physical_and_invitro.data,DTXSID%in%CvT.chems$DTXSID)
httk.data <- httk.data[,c(
  "Compound",
  "DTXSID",
  "CAS",
  "Human.Clint",
  "Human.Clint.pValue",
  "Human.Funbound.plasma")]


# Set insignificant trends to zero:
httk.data[httk.data$Human.Clint.pvalue < 0.05,"Human.Clint"] <- 0
colnames(httk.data)  
# Use medians from distributions:
httk.data$Human.Clint <- unlist(lapply(strsplit(httk.data$Human.Clint,","),function(x) as.numeric(x[1])))
httk.data$Human.Funbound.plasma <- 
  unlist(lapply(strsplit(httk.data$Human.Funbound.plasma,","),
  function(x) as.numeric(x[1])))
```

Add HTTK measured data to CvT.chems table:
```{r default_table, eval = TRUE}
CvT.chems <- merge(CvT.chems,
  httk.data[,c("DTXSID","Human.Clint","Human.Funbound.plasma")],
  all.x=TRUE,
  by="DTXSID")
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Clint"] <- "Human.Clint.httk"
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Funbound.plasma"] <- "Human.Fup.httk"
```





#Level I Predictions -- in vitro TK parameters:



At level I we are comparing QSAR's with the in vitro measured values.
We don't have those values for all the chemicals, so we only are comnparing on
a subset.

ADmet Sipes et al. (2017)
Pradeep et al. (submitted)
Dawson et al. (submitted)
OPERA (in prep.?)

Get the in vitro measured values:
In Vitro Measured:
```{r add_invitro, eval = TRUE}
reset_httk()
invitro <- subset(get_cheminfo(info="all"),DTXSID %in% CvT.chems$DTXSID)
invitro$Human.Clint <- sapply(invitro$Human.Clint,function(x) signif(as.numeric(strsplit(x,",")[[1]][[1]]),4))
invitro$Human.Funbound.plasma[invitro$Human.Funbound.plasma==0.005] <- NA
invitro$Human.Funbound.plasma <- sapply(invitro$Human.Funbound.plasma,function(x) signif(as.numeric(strsplit(x,",")[[1]][[1]]),4))
paste(dim(invitro)[1],"chemicals with in vitro measured data")

```

AdMet Predictor:
```{r add_admet, eval = TRUE}
# Simulations Plus (Sipes 2017):
clear_httk()
suppressWarnings(load_sipes2017(overwrite=T))
admet <- subset(get_cheminfo(info="all"),DTXSID %in% CvT.chems$DTXSID)
CvT.chems <- merge(CvT.chems,
  admet[,c("DTXSID","Human.Clint","Human.Funbound.plasma")],
  all.x=TRUE,
  by="DTXSID")
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Clint"] <- "Human.Clint.SPlus"
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Funbound.plasma"] <- "Human.Fup.SPlus"
```

Dawson 2021:
```{r add_dawson, eval = TRUE}
clear_httk()
load_dawson2021(overwrite=T)
dawson <- subset(get_cheminfo(info="all"),DTXSID %in% CvT.chems$DTXSID)
CvT.chems <- merge(CvT.chems,
  dawson[,c("DTXSID","Human.Clint","Human.Funbound.plasma")],
  all.x=TRUE,
  by="DTXSID")
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Clint"] <- "Human.Clint.Dawson"
colnames(CvT.chems)[colnames(CvT.chems)=="Human.Funbound.plasma"] <- "Human.Fup.Dawson"
```

Pradeep 2020:
```{r add_pradeep, eval = TRUE}
pradeep.clint <- read_excel("pradeep-Tox21_httk_predictions.xlsx",sheet=3)
pradeep.clint <- subset(pradeep.clint, pradeep.clint$...1 %in% CvT.chems$DTXSID)
CvT.chems <- merge(CvT.chems,
  pradeep.clint[,c("...1","pred_clint_rf")],
  all.x=TRUE,
  by.x="DTXSID",
  by.y="...1")
colnames(CvT.chems)[colnames(CvT.chems)=="pred_clint_rf"] <- "Human.Clint.Pradeep"
pradeep.fup <- read_excel("pradeep-Tox21_httk_predictions.xlsx",sheet=2)
pradeep.fup <- subset(pradeep.fup, pradeep.fup$dsstox_sid %in% CvT.chems$DTXSID)
CvT.chems <- merge(CvT.chems,
  pradeep.fup[,c("dsstox_sid","Consensus (SVM,RF)")],
  all.x=TRUE,
  by.x="DTXSID",
  by.y="dsstox_sid")
colnames(CvT.chems)[colnames(CvT.chems)=="Consensus (SVM,RF)"] <- 
  "Human.Fup.Pradeep"
```

OPERA Predictor:
```{r add_opera, eval = TRUE}
opera <- read.csv("testchems-smi_OPERA2.7Pred.csv",stringsAsFactors=F)
colnames(opera)[colnames(opera)=="MoleculeID"] <- "DTXSID"
opera <- subset(opera,DTXSID%in%CvT.chems$DTXSID)
# Domain of applicability:
opera[opera$AD_FUB==0,"FUB_pred"] <- NA
opera[opera$AD_Clint==0,"Clint_pred"] <- NA

CvT.chems <- merge(CvT.chems,
  opera[,c("DTXSID","Clint_pred","FUB_pred")],
  all.x=TRUE,
  by="DTXSID")
colnames(CvT.chems)[colnames(CvT.chems)=="Clint_pred"] <- "Human.Clint.OPERA"
colnames(CvT.chems)[colnames(CvT.chems)=="FUB_pred"] <- "Human.Fup.OPERA"
```

Master Table:
```{r prediction_table, eval = TRUE}
for (this.col in 12:21) 
{
  CvT.chems[,this.col] <- as.numeric(CvT.chems[,this.col])
  # Make the "zeros" log-transformable:
  for (this.row in 1:dim(CvT.chems)[1])
  {
    if (!is.na(CvT.chems[this.row,this.col]))
    {
      if (CvT.chems[this.row,this.col]==0)
      {
        
      }
    }
  }
}


```

Heatmap of the Data Set:
```{r make_heatmap, eval = TRUE}
  CvT.chems.scale <- CvT.chems
  colnames(CvT.chems.scale)[4] <- "Molecular Weight"
  colnames(CvT.chems.scale)[5] <- "Boiling Point"
  colnames(CvT.chems.scale)[6] <- "Henry's Law"
  colnames(CvT.chems.scale)[7] <- "Octanol:Air"
  colnames(CvT.chems.scale)[8] <- "Octanol:Water"
  colnames(CvT.chems.scale)[9] <- "Melting Point"
  colnames(CvT.chems.scale)[10] <- "Vapor Pressure"
  colnames(CvT.chems.scale)[11] <- "Water Solubility"
  rownames(CvT.chems.scale) <- CvT.chems.scale$PREFERRED_NAME 
# Make sure everything is numeric:
  for (this.col in 4:21) CvT.chems.scale[,this.col] <- 
    as.numeric(CvT.chems.scale[,this.col])
# Scale and center
  for (this.col in 4:11) CvT.chems.scale[,this.col] <- 
    (CvT.chems.scale[,this.col] - mean(CvT.chems.scale[,this.col],na.rm=TRUE)) / 
    sd(CvT.chems.scale[,this.col],na.rm=TRUE)
# scale and center all predictions by in vitro:
clint.mean <- mean(CvT.chems.scale[,12], na.rm=TRUE)
fup.mean <- mean(CvT.chems.scale[,13], na.rm=TRUE)
clint.sd <- sd(CvT.chems.scale[,12], na.rm=TRUE)
fup.sd <- sd(CvT.chems.scale[,13], na.rm=TRUE)
for (this.col in seq(12,20,2)) CvT.chems.scale[,this.col] <- 
    (CvT.chems.scale[,this.col] - clint.mean) / clint.sd
for (this.col in seq(13,21,2)) CvT.chems.scale[,this.col] <- 
    (CvT.chems.scale[,this.col] - fup.mean) / fup.sd


  
    mypalette<-brewer.pal(11,"RdYlBu")
  heatmap.2(as.matrix(CvT.chems.scale[,4:21]),
    lwid=c(0.4,1),
    lhei=c(0.4,1),
    margins=c(15,1),
    labRow = FALSE,
    cexCol=1,
    trace="none",
    col=mypalette)
```

Divide into individual tables:
```{r divide_tables, eval = TRUE}
level1tab <- CvT.chems


level1tab1 <- level1tab[,c(
  "DTXSID",
  "PREFERRED_NAME",
  "CASRN",
  "Human.Clint.httk","Human.Fup.httk",
  "Human.Clint.SPlus","Human.Fup.SPlus")]
level1tab1$QSAR <- "SPlus"
colnames(level1tab1)[6:7] <- c("Human.Clint.pred","Human.Fup.pred") 

level1tab2 <- level1tab[,c(
  "DTXSID",
  "PREFERRED_NAME",
  "CASRN","Human.Clint.httk","Human.Fup.httk",
  "Human.Clint.Dawson","Human.Fup.Dawson")]
level1tab2$QSAR <- "Dawson"
colnames(level1tab2)[6:7] <- c("Human.Clint.pred","Human.Fup.pred")

level1tab3 <- level1tab[,c(
  "DTXSID",
  "PREFERRED_NAME",
  "CASRN","Human.Clint.httk","Human.Fup.httk",
  "Human.Clint.Pradeep","Human.Fup.Pradeep")]
level1tab3$QSAR <- "Pradeep"
colnames(level1tab3)[6:7] <- c("Human.Clint.pred","Human.Fup.pred")

level1tab4 <- level1tab[,c(
  "DTXSID",
  "PREFERRED_NAME",
  "CASRN","Human.Clint.httk","Human.Fup.httk",
  "Human.Clint.OPERA","Human.Fup.OPERA")]
level1tab4$QSAR <- "OPERA"
colnames(level1tab4)[6:7] <- c("Human.Clint.pred","Human.Fup.pred")

level1tab <- rbind(level1tab1,level1tab2,level1tab3,level1tab4)
level1tab$Human.Fup.pred <- as.numeric(level1tab$Human.Fup.pred)
level1tab$Human.Clint.pred <- as.numeric(level1tab$Human.Clint.pred)
```
## calculate absolute fold error (AbsFE)
```{r calc_Level1AbsFE, eval=TRUE}

#Absolute fold error (AbsFE) : abs(log10(pred/obs))
level1tab$Human.Clint.AbsFE<-abs(log10(level1tab$Human.Clint.pred/level1tab$Human.Clint.httk))
level1tab$Human.fup.AbsFE<-abs(log10(level1tab$Human.Fup.pred/level1tab$Human.Fup.httk))

for (this.row in 1:dim(level1tab)[1])
{
  this.Clint.AbsFE <- level1tab[this.row,"Human.Clint.AbsFE"]
  if (!is.na(this.Clint.AbsFE))
  {
    if (!is.finite(this.Clint.AbsFE)) 
    {
#Turn -Inf and Inf into NA
      level1tab[this.row,"Human.Clint.AbsFE"] <- NA
    }
    if (is.nan(this.Clint.AbsFE)) 
    {
#Turn NaN into 0 , because the NaN is a result of matching 0/0...and hence it was correctly identified.
      level1tab[this.row,"Human.Clint.AbsFE"] <- 0
    }
  }
  this.fup.AbsFE <- level1tab[this.row,"Human.fup.AbsFE"]
  if (!is.na(this.fup.AbsFE))
  {
    if (!is.finite(this.fup.AbsFE)) 
    {
#Turn -Inf and Inf into NA
      level1tab[this.row,"Human.fup.AbsFE"] <- NA
    }
    if (is.nan(this.fup.AbsFE)) 
    {
#Turn NaN into 0 , because the NaN is a result of matching 0/0...and hence it was correctly identified.
      level1tab[this.row,"Human.fup.AbsFE"] <- 0
    }
  }  
}
```

# Let's try to avoid values that are just being retrieved from the training set:
```{r fold_error_cutoff, eval = TRUE}
TOOCLOSE.THRESHOLD <- 0.01
possible.training.chems <- NULL
for (this.row in 1:dim(level1tab)[1])
{
  clint <- level1tab[this.row,"Human.Clint.AbsFE"]
  fup <- level1tab[this.row,"Human.fup.AbsFE"]
  if (!is.na(clint))
  {
    if (!is.na(fup))
    {
      if (clint < TOOCLOSE.THRESHOLD & fup < TOOCLOSE.THRESHOLD)
      {
        possible.training.chems <- rbind(possible.training.chems,
                                         level1tab[this.row,])
        level1tab[this.row,"Human.Clint.pred"] <-NA
        level1tab[this.row,"Human.Clint.AbsFE"] <-NA
        level1tab[this.row,"Human.Fup.pred"] <-NA
        level1tab[this.row,"Human.fup.AbsFE"] <-NA
      }
    }
  }
}
```

Calculate RPE:     
```{r prediction_table, eval = TRUE}
level1tab[,"Human.Clint.RPE"] <- 
  (as.numeric(level1tab[,"Human.Clint.pred"]) - 
  as.numeric(level1tab[,"Human.Clint.httk"])) /
  as.numeric(level1tab[,"Human.Clint.httk"])
level1tab[,"Human.Fup.RPE"] <- 
  (as.numeric(level1tab[,"Human.Fup.pred"]) - 
  as.numeric(level1tab[,"Human.Fup.httk"])) /
  as.numeric(level1tab[,"Human.Fup.httk"])
  
hist(subset(level1tab,QSAR=="Dawson")$Human.Clint.RPE,main="Dawson",xlab="Clint RPE")
hist(subset(level1tab,QSAR=="Pradeep")$Human.Clint.RPE,main="Pradeep",xlab="Clint RPE")
hist(subset(level1tab,QSAR=="SPlus")$Human.Clint.RPE,main="SPlus",xlab="Clint RPE")
hist(subset(level1tab,QSAR=="OPERA")$Human.Clint.RPE,main="OPERA",xlab="Clint RPE")

hist(subset(level1tab,QSAR=="Dawson")$Human.Fup.RPE,main="Dawson",xlab="Fup RPE")
hist(subset(level1tab,QSAR=="Pradeep")$Human.Fup.RPE,main="Pradeep",xlab="Fup RPE")
hist(subset(level1tab,QSAR=="SPlus")$Human.Fup.RPE,main="SPlus",xlab="Fup RPE")
hist(subset(level1tab,QSAR=="OPERA")$Human.Fup.RPE,main="OPERA",xlab="Fup RPE")
```

Add average RPE where missing:
```{r interpolate_rpe, eval = TRUE}
for (this.chem in unique(level1tab$DTXSID))
{
  this.subset <- subset(level1tab,DTXSID==this.chem)
  this.mean.clint <- mean(this.subset$Human.Clint.RPE,na.rm=T)
  level1tab[level1tab$DTXSID==this.chem & is.na(level1tab$Human.Clint.RPE),
    "Human.Clint.RPE"] <- this.mean.clint
  this.mean.fup <- mean(this.subset$Human.Fup.RPE,na.rm=T)
  level1tab[level1tab$DTXSID==this.chem & is.na(level1tab$Human.Fup.RPE),
    "Human.Fup.RPE"] <- this.mean.fup
}
```

Check distribution of RPE for Clint:
```{r clint_rpe_hist, eval = TRUE}
hist(subset(level1tab,QSAR=="OPERA")$Human.Clint.RPE,main="OPERA",xlab="Clint RPE")
```
Check distribution of RPE for Fup:
```{r fup_rpe_hist, eval = TRUE}
hist(subset(level1tab,QSAR=="OPERA")$Human.Fup.RPE,main="OPERA",xlab="Fup RPE")
```

Make Level1 predictions vs. observed plot for Clint:
```{r clint_rpe_scatter, eval = TRUE}
FigLev1a <- ggplot(data=level1tab) +
  geom_point(size=3,aes(x=Human.Clint.pred+10^-4,y=Human.Clint.httk+10^-4,shape=QSAR,color=QSAR))+
  scale_x_log10(label=scientific_10) +
  scale_y_log10(label=scientific_10)+
  geom_abline(intercept = log10(10^(1/2)), slope = 1,linetype="dashed", colour="lightBlue") + 
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="Grey") + 
  geom_abline(intercept = log10(10^(-1/2)), slope = 1,linetype="dashed", colour="lightBlue") + 
  xlab(bquote('Predicted'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
  ylab(bquote('Observed'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
  theme_bw()+
  theme( text  = element_text(size=20))
print(FigLev1a)
```
Make Level1 predictions vs. observed plot for Clint (faceted):
```{r clint_rpe_scatter, eval = TRUE}

## Tiff image for manuscript (facet to see the individual predictions over Clint value)
FigLev1a_facet <- ggplot(data=level1tab) +
  geom_point(size=2,aes(x=Human.Clint.pred+10^-4,y=Human.Clint.httk+10^-4,shape=QSAR,color=QSAR))+
  scale_x_log10(breaks=c(10^-1,1,10,10^2),label=scientific_10,limits=c(30^-1,3000)) +
  #scale_y_log10(label=scientific_10)+
  scale_y_log10(breaks=c(10^-1,1,10,10^2),label=scientific_10,limits = c(30^-1, 3000))+
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="black",size=0.2) +
  #geom_abline(intercept = log10(3), slope = 1,linetype="dotted", colour="gray") +
  #geom_abline(intercept = -log10(3), slope = 1,linetype="dotted", colour="gray") +
  geom_abline(intercept = 1, slope = 1,linetype="dashed", colour="gray66",size=0.3) +
  geom_abline(intercept = -1, slope = 1,linetype="dashed", colour="gray66",size=0.3) +
  xlab(bquote('Predicted'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
  ylab(bquote('Observed'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
  theme_bw()+
  facet_grid(cols=vars(QSAR))+
  theme( text  = element_text(size=20),
         legend.position = "none",
         axis.title = element_text(size=20),
         axis.text.x = element_text(size=14))

print(FigLev1a_facet)
ggsave(paste("figs/FigLev1a_Clint_obsVpred_facet",output.prefix,".tiff",sep=""), width=4, height=1.7, dpi=300)
```

Make Level1 RPE boix and whisker plot for Clint:
  ```{r clint_rpe_boxwhisker, eval = TRUE}
FigLev1b <- ggplot(data=level1tab, aes(x=QSAR, y=Human.Clint.RPE)) + 
  geom_boxplot(outlier.colour="red",    
    outlier.size=2,
    outlier.alpha=0.1)+
  xlab("QSAR") +
  ylab(bquote("Relative Prediction Error in"~Cl[int]))+
  scale_y_log10(breaks=c(10^-2,10^-1,1,3,10,10^2,10^3),label=scientific_10)+
  theme_bw()+
  theme( text  = element_text(size=20))
  print(FigLev1b)  
```

## calculate some statistics
```{r calc_AbsFE_RMSE, eval=TRUE}

#Absolute Average Fold Error (AAFE) :  10^((1/n)*sum(abs(FE)))  ### use this. It's good to see fold error
ADMet.Human.Clint.AAFE<-10^(mean(level1tab$Human.Clint.AbsFE[level1tab$QSAR=="SPlus"],na.rm=TRUE))
Dawson.Human.Clint.AAFE<-10^(mean(level1tab$Human.Clint.AbsFE[level1tab$QSAR=="Dawson"],na.rm=TRUE))
OPERA.Human.Clint.AAFE<-10^(mean(level1tab$Human.Clint.AbsFE[level1tab$QSAR=="OPERA"],na.rm=TRUE))
Pradeep.Human.Clint.AAFE<-10^(mean(level1tab$Human.Clint.AbsFE[level1tab$QSAR=="Pradeep"],na.rm=TRUE))

ADMet.Human.fup.AAFE<-10^(mean(level1tab$Human.fup.AbsFE[level1tab$QSAR=="SPlus"],na.rm=TRUE))
Dawson.Human.fup.AAFE<-10^(mean(level1tab$Human.fup.AbsFE[level1tab$QSAR=="Dawson"],na.rm=TRUE))
OPERA.Human.fup.AAFE<-10^(mean(level1tab$Human.fup.AbsFE[level1tab$QSAR=="OPERA"],na.rm=TRUE))
Pradeep.Human.fup.AAFE<-10^(mean(level1tab$Human.fup.AbsFE[level1tab$QSAR=="Pradeep"],na.rm=TRUE))


#RMSLE sqrt(mean(log10(Xpred+1)-log10(Xobs+1))^2)  ### use this
ADMet.Human.Clint.RMSLE<-sqrt(mean((log10(level1tab$Human.Clint.pred[level1tab$QSAR=="SPlus"]+1)-log10(level1tab$Human.Clint.httk[level1tab$QSAR=="SPlus"]+1))^2,na.rm=TRUE))
Dawson.Human.Clint.RMSLE<-sqrt(mean((log10(level1tab$Human.Clint.pred[level1tab$QSAR=="Dawson"]+1)-log10(level1tab$Human.Clint.httk[level1tab$QSAR=="Dawson"]+1))^2,na.rm=TRUE))
OPERA.Human.Clint.RMSLE<-sqrt(mean((log10(level1tab$Human.Clint.pred[level1tab$QSAR=="OPERA"]+1)-log10(level1tab$Human.Clint.httk[level1tab$QSAR=="OPERA"]+1))^2,na.rm=TRUE))
Pradeep.Human.Clint.RMSLE<-sqrt(mean((log10(level1tab$Human.Clint.pred[level1tab$QSAR=="Pradeep"]+1)-log10(level1tab$Human.Clint.httk[level1tab$QSAR=="Pradeep"]+1))^2,na.rm=TRUE))

ADMet.Human.fup.RMSLE<-sqrt(mean((log10(level1tab$Human.Fup.pred[level1tab$QSAR=="SPlus"]+1)-log10(level1tab$Human.Fup.httk[level1tab$QSAR=="SPlus"]+1))^2,na.rm=TRUE))
Dawson.Human.fup.RMSLE<-sqrt(mean((log10(level1tab$Human.Fup.pred[level1tab$QSAR=="Dawson"]+1)-log10(level1tab$Human.Fup.httk[level1tab$QSAR=="Dawson"]+1))^2,na.rm=TRUE))
OPERA.Human.fup.RMSLE<-sqrt(mean((log10(level1tab$Human.Fup.pred[level1tab$QSAR=="OPERA"]+1)-log10(level1tab$Human.Fup.httk[level1tab$QSAR=="OPERA"]+1))^2,na.rm=TRUE))
Pradeep.Human.fup.RMSLE<-sqrt(mean((log10(level1tab$Human.Fup.pred[level1tab$QSAR=="Pradeep"]+1)-log10(level1tab$Human.Fup.httk[level1tab$QSAR=="Pradeep"]+1))^2,na.rm=TRUE))

Human.Clint.stats.table<-do.call("rbind",list(c(NA, "SPlus", "Dawson", "OPERA", "Pradeep"),
                                 c("AAFE",round(ADMet.Human.Clint.AAFE,2),
                                   round(Dawson.Human.Clint.AAFE,2),
                                   round(OPERA.Human.Clint.AAFE,2),
                                   round(Pradeep.Human.Clint.AAFE,2)),
                                 c("RMSLE",round(ADMet.Human.Clint.RMSLE,2),
                                           round(Dawson.Human.Clint.RMSLE,2),
                                           round(OPERA.Human.Clint.RMSLE,2),
                                           round(Pradeep.Human.Clint.RMSLE,2))))

Human.fup.stats.table<-do.call("rbind",list(c(NA, "SPlus", "Dawson", "OPERA", "Pradeep"),
                                              c("AAFE",round(ADMet.Human.fup.AAFE,2),
                                                round(Dawson.Human.fup.AAFE,2),
                                                round(OPERA.Human.fup.AAFE,2),
                                                round(Pradeep.Human.fup.AAFE,2)),
                                              c("RMSLE",round(ADMet.Human.fup.RMSLE,2),
                                                round(Dawson.Human.fup.RMSLE,2),
                                                round(OPERA.Human.fup.RMSLE,2),
                                                round(Pradeep.Human.fup.RMSLE,2))))
                                 
# colnames(Human.Clint.stats.table)<-Human.Clint.stats.table[1,]
# Human.Clint.stats.table<-Human.Clint.stats.table[2:3,]
# rownames(Human.Clint.stats.table)<-Human.Clint.stats.table[,1]
# Human.Clint.stats.table<-Human.Clint.stats.table[,2:5]

```
```{r clint_rpe_boxwhisker_stats, eval = TRUE}
#### add AAFE & RMSLE to the table
FigLev1b.texty <- -2
FigLev1b<-ggplot(data=level1tab, aes(x=QSAR, y=Human.Clint.RPE)) + 
  geom_boxplot(lwd=.3,  #reduce the boxplot linewidth
               outlier.shape=NA)+
  coord_cartesian(ylim=c(-3,8))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  xlab("QSAR") +
  ylab(bquote("Relative Error in"~Cl[int]))+
#  scale_y_log10(breaks=c(10^-3,10^-2,10^-1,1,10,10^2,10^3),label=scientific_10)+
  #scale_y_continuous(limits=c(-100,100))+
  theme_bw()+
  # annotation_custom(tableGrob(Human.Clint.stats.table,theme = ttheme_default(base_size = 5),padding.h = unit(1, "mm")), ymin=-5, ymax=-2.5)+
  #  annotation_custom(tableGrob(Human.Clint.stats.table,padding.v=unit(1, "mm")), ymin=-5, ymax=-2.5)+
  
  annotation_custom(tableGrob(Human.Clint.stats.table[2:3,1], theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=1.5,ymin=(FigLev1b.texty-1),ymax=FigLev1b.texty)+
  annotation_custom(tableGrob(Human.Clint.stats.table[2:3,3],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=2.3,ymin=(FigLev1b.texty-1),ymax=FigLev1b.texty)+
  annotation_custom(tableGrob(Human.Clint.stats.table[2:3,4],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=4.3,ymin=(FigLev1b.texty-1),ymax=FigLev1b.texty)+
  annotation_custom(tableGrob(Human.Clint.stats.table[2:3,5],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=6.3,ymin=(FigLev1b.texty-1),ymax=FigLev1b.texty)+
  annotation_custom(tableGrob(Human.Clint.stats.table[2:3,2],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=8.3,ymin=(FigLev1b.texty-1),ymax=FigLev1b.texty)+
  
  theme( text  = element_text(size=20),
         legend.key.height=unit(.5,"line"),
         legend.text=element_text(size=7),
         legend.title = element_text(size=8))
print(FigLev1b) 
ggsave(paste("figs/FigLev1b_Clint_boxplot_wtable",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)
```
```{r fup_rpe_boxwhisker_stats, eval = TRUE}

FigLev1c <- ggplot(data=level1tab) +
  geom_point(size=3,aes(x=Human.Fup.pred+10^-4,y=Human.Fup.httk+10^-4,shape=QSAR,color=QSAR))+
  scale_x_log10(label=scientific_10) +
  scale_y_log10(label=scientific_10)+
  geom_abline(intercept = log10(10^(1/2)), slope = 1,linetype="dashed", colour="lightBlue") +
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="Grey") + 
  geom_abline(intercept = log10(10^(-1/2)), slope = 1,linetype="dashed", colour="lightBlue") + 
  xlab(bquote('Predicted'~f[up])) +
  ylab(bquote('Observed'~f[up])) +
  theme_bw()+
  theme( text  = element_text(size=20))
print(FigLev1c)
```
```{r fup_rpe_boxwhisker_faceted, eval = TRUE}

## faceted
FigLev1c <- ggplot(data=level1tab) +
  geom_point(size=2,aes(x=Human.Fup.pred+10^-4,y=Human.Fup.httk+10^-4,shape=QSAR,color=QSAR))+
  ##  scale_x_log10(label=scientific_10) +
  scale_x_log10(breaks=c(10^-8,10^-6,10^-4,10^-2,1),label=scientific_10)+
  ##  scale_y_log10(label=scientific_10)+
  scale_y_log10(breaks=c(10^-8,10^-6,10^-4,10^-2,1),label=scientific_10)+
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="black",size=0.2) +
  # geom_abline(intercept = log10(3), slope = 1,linetype="dotted", colour="gray") +
  #geom_abline(intercept = -log10(3), slope = 1,linetype="dotted", colour="gray") +
  geom_abline(intercept = 1, slope = 1,linetype="dashed", colour="gray66",size=0.3) +
  geom_abline(intercept = -1, slope = 1,linetype="dashed", colour="gray66",size=0.3) +
  xlab(bquote('Predicted'~f[up])) +
  ylab(bquote('Observed'~f[up])) +
  facet_grid(cols=vars(QSAR))+
  theme_bw()+
  theme( text  = element_text(size=20),
         legend.position = "none",
         axis.title = element_text(size=20),
         axis.text.x = element_text(size=14))
print(FigLev1c)
ggsave(paste("figs/FigLev1c_Fub_obsVpred_facet",output.prefix,".tiff",sep=""), width=4, height=1.7, dpi=300)
#ggsave(paste("figs/FigLev1c_Fub_obsVpred_facet_PradeepNEW",output.prefix,".tiff",sep=""), width=4, height=1.7, dpi=300)

```
```{r fup_rpe_boxwhisker_stats, eval = TRUE}
FigLev1d <- ggplot(data=level1tab, aes(x=QSAR, y=Human.Fup.RPE)) + 
  geom_boxplot(outlier.colour="red",    
    outlier.size=2,
    outlier.alpha=0.1)+
  xlab("QSAR") +
  ylab(bquote("Relative Prediction Error in"~f[up]))+
  scale_y_log10(breaks=c(10^-2,10^-1,1,3,10,10^2,10^3),label=scientific_10)+
  theme_bw()+
  theme( text  = element_text(size=20))
print(FigLev1d)  


```
```{r fup_rpe_boxwhisker_stats, eval = TRUE}

#### add AAFE & RMSLE to the table

texty <- 3
FigLev1d<-ggplot(data=level1tab, aes(x=QSAR, y=Human.Fup.RPE)) + 
  geom_boxplot(lwd=.3,  #reduce the boxplot linewidth
               outlier.shape=NA)+
 # coord_cartesian(ylim=c(-3,6))+ ### Pradeep NEW !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  coord_cartesian(ylim=c(-1.5,3))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  
  xlab("QSAR") +
  ylab(bquote("Relative Error in"~f[up]))+
#  scale_y_log10(breaks=c(10^-3,10^-2,10^-1,1,10,10^2,10^3),label=scientific_10)+
#  scale_y_continuous(limits=c(-3,5))+
  theme_bw()+
  # annotation_custom(tableGrob(Human.Clint.stats.table,theme = ttheme_default(base_size = 5),padding.h = unit(1, "mm")), ymin=-5, ymax=-2.5)+
  #  annotation_custom(tableGrob(Human.Clint.stats.table,padding.v=unit(1, "mm")), ymin=-5, ymax=-2.5)+
  
  annotation_custom(tableGrob(Human.fup.stats.table[2:3,1], theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=1.5,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(Human.fup.stats.table[2:3,2],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=2.3,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(Human.fup.stats.table[2:3,3],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=4.3,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(Human.fup.stats.table[2:3,4],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=6.3,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(Human.fup.stats.table[2:3,5],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=8.3,ymin=(texty-1),ymax=texty)+
  
  theme( text  = element_text(size=20),
         legend.key.height=unit(.5,"line"),
         legend.text=element_text(size=7),
         legend.title = element_text(size=8))
print(FigLev1d) 
ggsave(paste("figs/FigLev1d_fup_boxplot_wtable",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)
#ggsave(paste("figs/FigLev1d_fup_boxplot_wtable_PradeepNEW",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)
```



#
#
#Level II Predictions -- CvT data
#
#

# At level II we are comparing predictions made using QSAR values with actual
# tissue concentration vs. time data. Most of the QSAR values are used with the
# HTTK PBTK model to make predictions. I hope to get ADmet predictor PBTK
# predictions too.
#
# Level I included the predictions made with the in vitro measured values, but this 
# is a subset of the total chemicals. Should probably run all statistics both
# for all chemicals and just the subset to make sure that the QSARs aren't 
# affected by weird chemcials with no in vitro measured values. But I haven't 
# done this yet.


# HTTK PBTK with in vitro measured values
# HTTK PBTK with ADmet
# HTTK PBTK with Pradeep
# HTTK PBTK with Dawson
# HTTK PBTK with OPERA
# ADmet predictor

# Load metabolism data (chemical-enzyme mapping):
```{r load_chemcyps, eval = TRUE}
pharm <- read.csv("jm0613471_si_002.txt",sep="\t")
pharm <- subset(pharm,DTXSID!="-")
pest <- read_excel("Abass2012.xlsx")
pharm <- pharm[,c("Compound","PREFERRED_NAME","DTXSID","CASRN","ISOFORM","Author")]
pest <- pest[,c("Pesticide","PREFERRED_NAME","DTXSID","CASRN","Enzyme","Reference")]
colnames(pest) <- colnames(pharm)
cyps <- rbind(pharm,pest)

```

# We load the TK stats (Level III) at this point because it makes sense to do
# the Level II and III calculations are the same time (rather than rewriting 
# the parameter values twice).
# TK Stats (including Vd and thalf) calculated from CvTdb:
```{r load_compartmental_model_parameters, eval = TRUE}
fits1comp <- read.csv("PK.fit.table.1comp.new.nobounds.csv")
fits1comp <- subset(fits1comp, is.finite(AIC) & AIC < 10^4)
fits2comp <- read.csv("PK.fit.table.2comp.new.nobounds.csv")
fits2comp <- subset(fits2comp, is.finite(AIC) & AIC < 10^4)

#How many chemicals have 1 or 2 compartment fits:
length(unique(c(fits1comp$CAS,fits2comp$CAS)))

fittable <- NULL
for (this.cas in unique(c(fits1comp$CAS,fits2comp$CAS)))
{
  
  Vdist.1comp <- NA
  kelim.1comp <- NA
  Vdist.2comp <- NA
  kelim.2comp <- NA
  this.row <- data.frame(
    CAS=this.cas,
    AIC.1comp=NA,
    AIC.2comp=NA,
    Model=NA,
    Vdist=NA,
    kelim=NA)
  if (this.cas %in% fits1comp$CAS)
  {
    this.data <- subset(fits1comp,
      CAS==this.cas & param.value.type=="Fitted geometric mean")
    if (dim(this.data)[1]>1)
    {
      this.data <- subset(this.data, Data.Analyzed=="Joint Analysis")
    }
    if (dim(this.data)[1]>0) 
    {
      this.row$AIC.1comp <- this.data$AIC
      Vdist.1comp <- this.data$Vdist
      kelim.1comp <- this.data$kelim
    }
  }
  if (this.cas %in% fits2comp$CAS)
  {
    this.data <- subset(fits2comp,
      CAS==this.cas & param.value.type=="Fitted geometric mean")
    if (dim(this.data)[1]>1)
    {
      this.data <- subset(this.data, Data.Analyzed=="Joint Analysis")
    }
    if (dim(this.data)[1]>0) 
    {
      this.row$AIC.2comp <- this.data$AIC
      Vdist.2comp <- this.data$Vss
      kelim.2comp <- this.data$kelim
    }
  }
  if (!is.na(this.row$AIC.1comp))
  {
    if (!is.na(this.row$AIC.2comp))
    {
      if (this.row$AIC.1comp < this.row$AIC.2comp)
      {
        this.row$Model <- "1Comp"
      } else this.row$Model <- "2Comp"
    } else this.row$Model <- "1Comp"
  } else if (!is.na(this.row$AIC.2comp))
  {
    this.row$Model <- "2Comp"
  }

  if (!is.na(this.row$Model))
    if (this.row$Model == "1Comp")
    {
      this.row$Vdist <- Vdist.1comp
      this.row$kelim <- kelim.1comp
    } else 
    {
      this.row$Vdist <- Vdist.2comp
      this.row$kelim <- kelim.2comp
    }      
  
  fittable <- rbind(fittable,this.row)
}
fittable$halflife <- log(2)/fittable$kelim

#Lets only keep chemicals where we can fit a PK model:
fittable <- subset(fittable, !is.na(Model))

for (this.col in c("AIC.1comp","AIC.2comp","Vdist","kelim","halflife"))
  fittable[,this.col] <- signif(as.numeric(fittable[,this.col]),4)

# We have parameters estimated for 86 chemicals:
dim(fittable)[1]
```
There are ten chemicals where only opera could make predictions:
```{r separate_out_opera_only, eval=TRUE}
CvT.chems.opera <- subset(CvT.chems,DTXSID %in% c(
  "DTXSID0022985",
  "DTXSID1051432",
  "DTXSID3032179",
  "DTXSID30575892",
  "DTXSID3061635",
  "DTXSID5020285",
  "DTXSID5024219",
  "DTXSID50881104",
  "DTXSID7030066",
  "DTXSID80108992"))
CvT.chems <- subset(CvT.chems,!(DTXSID %in% c(
  "DTXSID0022985",
  "DTXSID1051432",
  "DTXSID3032179",
  "DTXSID30575892",
  "DTXSID3061635",
  "DTXSID5020285",
  "DTXSID5024219",
  "DTXSID50881104",
  "DTXSID7030066",
  "DTXSID80108992")))
CvT.data.opera <- subset(CvT.data,DTXSID %in% c(
  "DTXSID0022985",
  "DTXSID1051432",
  "DTXSID3032179",
  "DTXSID30575892",
  "DTXSID3061635",
  "DTXSID5020285",
  "DTXSID5024219",
  "DTXSID50881104",
  "DTXSID7030066",
  "DTXSID80108992"))
CvT.data <- subset(CvT.data,!(DTXSID %in% c(
  "DTXSID0022985",
  "DTXSID1051432",
  "DTXSID3032179",
  "DTXSID30575892",
  "DTXSID3061635",
  "DTXSID5020285",
  "DTXSID5024219",
  "DTXSID50881104",
  "DTXSID7030066",
  "DTXSID80108992")))
```
There are chemicals where the in vivo data don't permit empirical fits, drop
those from the level II/III evaluation:
```{r separate_out_badfits, eval=TRUE}
CvT.chems.nofits <- CvT.chems[!(CvT.chems$CASRN%in%fittable$CAS),]
CvT.data <- subset(CvT.data, CAS %in% fittable$CAS)
length(unique(CvT.data$CAS)) # Number of chemicals with good fits
```
Get rid of chemical predictions that are possibly just training set lookups:
```{r remove_training_chems, eval=TRUE}
CvT.chems.notraining <- CvT.chems
for (this.qsar in unique(possible.training.chems$QSAR))
{
  this.subset <- subset(possible.training.chems, QSAR==this.qsar)
  for (this.id in this.subset$DTXSID)
  {
    CvT.chems.notraining[CvT.chems.notraining$DTXSID==this.id,
      paste("Human.Clint",this.qsar,sep=".")]<-NA
    CvT.chems.notraining[CvT.chems.notraining$DTXSID==this.id,
      paste("Human.Fup",this.qsar,sep=".")]<-NA
  }
}
dim(CvT.chems.notraining)
```

# Get rid of chemicals with only OPERA predictions, or bad empirical fits:
```{r remove_problem_chems, eval=TRUE}
CvT.chems.nobad <- subset(CvT.chems.notraining,
                          !(DTXSID %in% CvT.chems.opera$DTXSID) &
                          !(DTXSID %in% CvT.chems.nofits$DTXSID))
dim(CvT.chems.nobad)
dim(CvT.data)
CvT.data <- subset(CvT.data,CAS%in%CvT.chems.nobad$CASRN)
dim(CvT.data)
```
Make a version of the prediction matrix where we've smoothed out missing data:
```{r remove_missing_predictions, eval = TRUE}
CvT.chems.nona <- CvT.chems.nobad
clint.cols <- c(12,14,16,18,20)
fup.cols <- c(13,15,17,19,21)
# Can't run PBTK for fup=0
for (this.col in fup.cols)
  CvT.chems.nona[is.na(CvT.chems.nona[,this.col]),this.col]<-0
for (this.col in fup.cols)
  CvT.chems.nona[CvT.chems.nona[,this.col]==0,this.col]<-NA


for (this.chem in CvT.chems.nona$DTXSID)
{
  this.row <- which(CvT.chems.nona$DTXSID==this.chem)
# Check Clints:
  if (all(is.na(CvT.chems.nona[this.row,clint.cols])))
  {
    CvT.chems.nona <- subset(CvT.chems.nona,DTXSID!=this.chem)
  } else if (any(is.na(CvT.chems.nona[this.row,clint.cols])))
  {
    this.mean <- mean(as.numeric(CvT.chems.nona[this.row,clint.cols]),na.rm=T)
    for (this.col in clint.cols)
      if (is.na(CvT.chems.nona[this.row,this.col])) 
        CvT.chems.nona[this.row,this.col] <- this.mean
  }
# Check fups:
  if (all(is.na(CvT.chems.nona[this.row,fup.cols])))
  {
    CvT.chems.nona <- subset(CvT.chems.nona,DTXSID!=this.chem)
  } else if (any(is.na(CvT.chems.nona[this.row,fup.cols])) |
      any(sapply(CvT.chems.nona[this.row,fup.cols],is.nan)))
  {
    this.mean <- mean(as.numeric(CvT.chems.nona[this.row,fup.cols]),na.rm=T)
    for (this.col in fup.cols)
      if (is.na(CvT.chems.nona[this.row,this.col]) |
          is.nan(CvT.chems.nona[this.row,this.col])) 
        CvT.chems.nona[this.row,this.col] <- this.mean
  }
}
```


Make predictions of CvT using in vitro measured data. Rather than use default
HTTK (which also pulls in things like blood to plasma ratio) we'll wipe out 
everything and then add just Clint and Fup each time:
```{r cvt_compare_invitro, eval = TRUE}
clear_httk()
chem.physical_and_invitro.data <- add_chemtable(
  CvT.chems.nona,
  current.table=chem.physical_and_invitro.data,
  data.list=list(
    Compound="PREFERRED_NAME",
    DTXSID="DTXSID",
    CAS="CASRN",
    Funbound.plasma="Human.Fup.httk",
    Clint="Human.Clint.httk"),
  species="Human",
  reference="InVitro",
  overwrite=TRUE)
print(paste(length(get_cheminfo(model="pbtk")),"chemicals for PBTK"))
level2tab.invitro.list <- makeCvTpreds(CvT.data,"HTTK-InVitro")
level2tab.invitro <- level2tab.invitro.list$cvt
level2tab.invitro.stats <- level2tab.invitro.list$stats
level3tab.invitro <- maketkstatpreds(CvT.data,fittable,"HTTK-InVitro")
```

```{r cvt_compare_admet, eval = TRUE}
clear_httk()
chem.physical_and_invitro.data <- add_chemtable(
  CvT.chems.nona,
  current.table=chem.physical_and_invitro.data,
  data.list=list(
    Compound="PREFERRED_NAME",
    DTXSID="DTXSID",
    CAS="CASRN",
    Funbound.plasma="Human.Fup.SPlus",
    Clint="Human.Clint.SPlus"),
  species="Human",
  reference="SPlus",
  overwrite=TRUE)
print(paste(length(get_cheminfo(model="pbtk")),"chemicals for PBTK"))
level2tab.admet.list <- makeCvTpreds(CvT.data,"HTTK-ADmet")
level2tab.admet <- level2tab.admet.list$cvt
level2tab.admet.stats <- level2tab.admet.list$stats
level3tab.admet <- maketkstatpreds(CvT.data,fittable,"HTTK-ADmet")
```

```{r cvt_compare_dawson, eval = TRUE}
clear_httk()
chem.physical_and_invitro.data <- add_chemtable(
  CvT.chems.nona,
  current.table=chem.physical_and_invitro.data,
  data.list=list(
    Compound="PREFERRED_NAME",
    DTXSID="DTXSID",
    CAS="CASRN",
    Funbound.plasma="Human.Fup.Dawson",
    Clint="Human.Clint.Dawson"),
  species="Human",
  reference="Dawson",
  overwrite=TRUE)
print(paste(length(get_cheminfo(model="pbtk")),"chemicals for PBTK"))
level2tab.dawson.list <- makeCvTpreds(CvT.data,"HTTK-Dawson")
level2tab.dawson <- level2tab.dawson.list$cvt
level2tab.dawson.stats <- level2tab.dawson.list$stats
level3tab.dawson <- maketkstatpreds(CvT.data,fittable,"HTTK-Dawson")
```

```{r cvt_compare_pradeep, eval = TRUE}
clear_httk()
chem.physical_and_invitro.data <- add_chemtable(
  CvT.chems.nona,
  current.table=chem.physical_and_invitro.data,
  data.list=list(
    Compound="PREFERRED_NAME",
    DTXSID="DTXSID",
    CAS="CASRN",
    Funbound.plasma="Human.Fup.Pradeep",
    Clint="Human.Clint.Pradeep"),
  species="Human",
  reference="Pradeep",
  overwrite=TRUE)
print(paste(length(get_cheminfo(model="pbtk")),"chemicals for PBTK"))
level2tab.pradeep.list <- makeCvTpreds(CvT.data,"HTTK-Pradeep")
level2tab.pradeep <- level2tab.pradeep.list$cvt
level2tab.pradeep.stats <- level2tab.pradeep.list$stats
level3tab.pradeep <- maketkstatpreds(CvT.data,fittable,"HTTK-Pradeep")

```

# Add OPERA predictions:
```{r cvt_compare_opera, eval = TRUE}
clear_httk()
chem.physical_and_invitro.data <- add_chemtable(
  CvT.chems.nona,
  current.table=chem.physical_and_invitro.data,
  data.list=list(
    Compound="PREFERRED_NAME",
    DTXSID="DTXSID",
    CAS="CASRN",
    Funbound.plasma="Human.Fup.OPERA",
    Clint="Human.Clint.OPERA"),
  species="Human",
  reference="OPERA",
  overwrite=T)
print(paste(length(get_cheminfo(model="pbtk")),"chemicals for PBTK"))
level2tab.opera.list <- makeCvTpreds(CvT.data,"HTTK-OPERA")
level2tab.opera <- level2tab.opera.list$cvt
level2tab.opera.stats <- level2tab.opera.list$stats
level3tab.opera <- maketkstatpreds(CvT.data,fittable,"HTTK-OPERA")
```

# The performance of actual 1 compartment model fits provides an upper limit
# of how good we can get (thanks Rusty)
```{r cvt_compare_fits, eval = TRUE}
level2tab.fits.list <- makeCvTpredsfromfits(
  CvT.data,
  fits1comp,
  fits2comp,
  "FitsToData")
level2tab.fits <-  level2tab.fits.list$cvt
level2tab.fits.stats <- level2tab.fits.list$stats
```

```{r cvt_onering, eval = TRUE}
level2tab <- rbind(
  level2tab.invitro,
  level2tab.admet,
  level2tab.dawson,
  level2tab.pradeep,
  level2tab.opera,
  level2tab.fits)
level2tab <- subset(level2tab,!duplicated(level2tab))

level2tab.stats <- rbind(
  level2tab.invitro.stats,
  level2tab.admet.stats,
  level2tab.dawson.stats,
  level2tab.pradeep.stats,
  level2tab.opera.stats,
  level2tab.fits.stats)
level2tab.stats <- subset(level2tab.stats,!duplicated(level2tab.stats))
# Occasionally we can't calculate AUC, get rid of these data:
level2tab.stats <- subset(level2tab.stats, !is.na(AUC.obs))
```

Assign average to missing predictions:
```{r smooth_missing, eval = TRUE}
  QSARs <- unique(level2tab$QSAR)
  for (this.chem in unique(level2tab$CAS))
  {
    this.subset1 <- subset(level2tab,CAS==this.chem)
    for (this.species in unique(this.subset1$Species))
    {
      this.subset2 <- subset(this.subset1,Species==this.species)
      for (this.route in unique(this.subset2$Route))
      {
        this.subset3 <- subset(this.subset2,Route==this.route)
        for (this.dose in unique(this.subset3$Dose))
        {
          this.subset4 <- subset(this.subset3,Dose==this.dose)
          for (this.time in unique(this.subset4$Time))
          {
            this.subset5 <- subset(this.subset4,Time==this.time)
            for (this.obs in unique(this.subset5$Conc.obs))
            {
              this.subset6 <- subset(this.subset5,Conc.obs==this.obs)
              mean.pred <- mean(this.subset6$Conc.pred,na.rm=TRUE)
              for (this.QSAR in QSARs)
              {
                if (!(this.QSAR %in% this.subset6$QSAR))
                {
                  this.row <- this.subset6[1,]
                  this.row$QSAR <- this.QSAR
                  this.row$Conc.pred <- mean.pred
                  level2tab <- rbind(level2tab,this.row)
                }
              }
            }
          }
        }
      }
    }
  }      
```
  
```{r calc_level2_rpe, eval = TRUE}
  # Calculate RPE:
  level2tab$Conc.obs <- as.numeric(level2tab$Conc.obs)
  level2tab$Conc.pred <- as.numeric(level2tab$Conc.pred) 
  # Let's treat all "low" values as the same, where we define low with loq:
  level2tab$Conc.obs[level2tab$Conc.obs<level2tab$calc_loq] <- 
    level2tab[level2tab$Conc.obs<level2tab$calc_loq,"calc_loq"]
  level2tab$Conc.pred[level2tab$Conc.pred<level2tab$calc_loq] <- 
    level2tab[level2tab$Conc.pred<level2tab$calc_loq,"calc_loq"]
  
  level2tab$RPE <- (level2tab$Conc.pred-level2tab$Conc.obs)/level2tab$Conc.obs
  level2tab[level2tab$RPE>5,"RPE"] <- 5
  hist(level2tab$RPE)

level2tab.stats$AUC.RPE <- (level2tab.stats$AUC.pred-level2tab.stats$AUC.obs)/level2tab.stats$AUC.obs
level2tab.stats[level2tab.stats$AUC.RPE>5,"AUC.RPE"] <- 5
hist(level2tab.stats$AUC.RPE)

level2tab.stats$Cmax.RPE <- (level2tab.stats$Cmax.pred-level2tab.stats$Cmax.obs)/level2tab.stats$Cmax.obs
level2tab.stats[level2tab.stats$Cmax.RPE>5,"Cmax.RPE"] <- 5
hist(level2tab.stats$Cmax.RPE)
     
#level2tab$RPE.trunc[level2tab$RPE.trunc < -100] <- -100
#level2tab$RPE.trunc[level2tab$RPE.trunc > 100] <- 100
 
#Turn -Inf and Inf into NA .... we don't need this because no $Conc.obs are 0, but it's good practice to write here
level2tab$RPE[level2tab$RPE=="Inf"]<-NA
level2tab$RPE[level2tab$RPE=="-Inf"]<-NA
#Turn NaN into 0 , because the NaN is a result of matching 0/0...and hence it was correctly identified.

### but we don't need this because no $Conc.obs are 0, but it's good practice to write here
level2tab$RPE[level2tab$RPE=="NaN"]<-0
 

source.table <- NULL
for (this.source in unique(level2tab$Source))
{
  this.subset <- subset(level2tab,Source==this.source)
  this.row <- this.subset[1,c(1:3,11)]
  this.row$RPE <- mean(this.subset$RPE)
  source.table <- rbind(source.table,this.row)
}
for (this.chem in unique(source.table$Compound))
{
  this.subset <- subset(source.table,Compound==this.chem)
  source.table[source.table$Compound==this.chem,"RPE.sd"] <- sd(this.subset$RPE)
}
source.table <- source.table[order(source.table$RPE.sd),]
write.csv(source.table,file="modelerrorsbysource.txt",row.names=F)
```

#################################################################################
## calculate some statistics
```{r calc_level2_AbsFE_RMSE, eval = TRUE}
#Absolute fold error (AbsFE) : abs(log10(pred/obs))
level2tab$AbsFE<-abs(log10(level2tab$Conc.pred/level2tab$Conc.obs))

#Turn -Inf and Inf into NA
level2tab$AbsFE[level2tab$AbsFE=="Inf"]<-4   ######## lots because lots of $Conc.pred is zero
hist(level2tab$AbsFE)  # 4 seems large but does not to mess up the distribution

#Turn NaN into 0 , because the NaN is a result of matching 0/0...and hence it was correctly identified.
level2tab$AbsFE[level2tab$AbsFE=="NaN"]<-0  #none
```


```{r divide_cvt_bytime, eval = TRUE}
level2tab.early <- NULL
level2tab.late <- NULL
for (this.study in unique(level2tab$Source))
{
  this.subset1 <- subset(level2tab,Source==this.study)
  for (this.chem in unique(this.subset1$CAS))
  {
    this.subset2 <- subset(this.subset1,CAS==this.chem)
    mid.time <- mean(unique(this.subset2$Time))
    level2tab.early <- rbind(level2tab.early,
      subset(this.subset2,Time < mid.time))
    level2tab.late <- rbind(level2tab.late,
      subset(this.subset2,Time >= mid.time))
  }
}
```

```{r calc_setspeific_stats, eval = TRUE}
#Absolute Average Fold Error (AAFE) :  10^((1/n)*sum(abs(FE)))  ### use this. It's good to see fold error
ADMet.AAFE<-10^(mean(level2tab$AbsFE[
  level2tab$QSAR=="HTTK-ADmet"],na.rm=TRUE))
Dawson.AAFE<-10^(mean(level2tab$AbsFE[
  level2tab$QSAR=="HTTK-Dawson"],na.rm=TRUE))
InVitro.AAFE<-10^(mean(level2tab$AbsFE[
  level2tab$QSAR=="HTTK-InVitro"],na.rm=TRUE))
OPERA.AAFE<-10^(mean(level2tab$AbsFE[
  level2tab$QSAR=="HTTK-OPERA"],na.rm=TRUE))
Pradeep.AAFE<-10^(mean(level2tab$AbsFE[
  level2tab$QSAR=="HTTK-Pradeep"],na.rm=TRUE))
fits.AAFE<-10^(mean(level2tab$AbsFE[
  level2tab$QSAR=="FitsToData"],na.rm=TRUE))

#Absolute Average Fold Error (AAFE) :  10^((1/n)*sum(abs(FE)))  ### use this. It's good to see fold error
ADMet.AAFE.early <- 10^(mean(level2tab.early$AbsFE[
  level2tab.early$QSAR=="HTTK-ADmet"],na.rm=TRUE))
Dawson.AAFE.early <- 10^(mean(level2tab.early$AbsFE[
  level2tab.early$QSAR=="HTTK-Dawson"],na.rm=TRUE))
InVitro.AAFE.early <- 10^(mean(level2tab.early$AbsFE[
  level2tab.early$QSAR=="HTTK-InVitro"],na.rm=TRUE))
OPERA.AAFE.early <- 10^(mean(level2tab.early$AbsFE[
  level2tab.early$QSAR=="HTTK-OPERA"],na.rm=TRUE))
Pradeep.AAFE.early <- 10^(mean(level2tab.early$AbsFE[
  level2tab.early$QSAR=="HTTK-Pradeep"],na.rm=TRUE))
fits.AAFE.early <- 10^(mean(level2tab.early$AbsFE[
  level2tab.early$QSAR=="FitsToData"],na.rm=TRUE))

#Absolute Average Fold Error (AAFE) :  10^((1/n)*sum(abs(FE)))  ### use this. It's good to see fold error
ADMet.AAFE.late <- 10^(mean(level2tab.late$AbsFE[
  level2tab.late$QSAR=="HTTK-ADmet"],na.rm=TRUE))
Dawson.AAFE.late <- 10^(mean(level2tab.late$AbsFE[
  level2tab.late$QSAR=="HTTK-Dawson"],na.rm=TRUE))
InVitro.AAFE.late <- 10^(mean(level2tab.late$AbsFE[
  level2tab.late$QSAR=="HTTK-InVitro"],na.rm=TRUE))
OPERA.AAFE.late <- 10^(mean(level2tab.late$AbsFE[
  level2tab.late$QSAR=="HTTK-OPERA"],na.rm=TRUE))
Pradeep.AAFE.late <- 10^(mean(level2tab.late$AbsFE[
  level2tab.late$QSAR=="HTTK-Pradeep"],na.rm=TRUE))
fits.AAFE.late <- 10^(mean(level2tab.late$AbsFE[
  level2tab.late$QSAR=="FitsToData"],na.rm=TRUE))

#RMSLE sqrt(mean(log10(Xpred+1)-log10(Xobs+1))2)  ### use this
ADMet.RMSLE<-sqrt(mean((log10(level2tab$Conc.pred[level2tab$QSAR=="HTTK-ADmet"]/
  level2tab$Conc.obs[level2tab$QSAR=="HTTK-ADmet"]))^2,na.rm=TRUE))
Dawson.RMSLE<-sqrt(mean((log10(level2tab$Conc.pred[level2tab$QSAR=="HTTK-Dawson"]/
  level2tab$Conc.obs[level2tab$QSAR=="HTTK-Dawson"]))^2,na.rm=TRUE))
InVitro.RMSLE<-sqrt(mean((log10(level2tab$Conc.pred[level2tab$QSAR=="HTTK-InVitro"]/
  level2tab$Conc.obs[level2tab$QSAR=="HTTK-InVitro"]))^2,na.rm=TRUE))
OPERA.RMSLE<-sqrt(mean((log10(level2tab$Conc.pred[level2tab$QSAR=="HTTK-OPERA"]/
  level2tab$Conc.obs[level2tab$QSAR=="HTTK-OPERA"]))^2,na.rm=TRUE))
Pradeep.RMSLE<-sqrt(mean((log10(level2tab$Conc.pred[level2tab$QSAR=="HTTK-Pradeep"]/
  level2tab$Conc.obs[level2tab$QSAR=="HTTK-Pradeep"]))^2,na.rm=TRUE))
fits.RMSLE<-sqrt(mean((log10(level2tab$Conc.pred[level2tab$QSAR=="FitsToData"]/
  level2tab$Conc.obs[level2tab$QSAR=="FitsToData"]))^2,na.rm=TRUE))

ADMet.RMSLE.early <-sqrt(mean((log10(level2tab.early$Conc.pred[
  level2tab.early$QSAR=="HTTK-ADmet"]/
  level2tab.early$Conc.obs[level2tab.early$QSAR=="HTTK-ADmet"]))^2,na.rm=TRUE))
Dawson.RMSLE.early <-sqrt(mean((log10(level2tab.early$Conc.pred[
  level2tab.early$QSAR=="HTTK-Dawson"]/
  level2tab.early$Conc.obs[level2tab.early$QSAR=="HTTK-Dawson"]))^2,na.rm=TRUE))
InVitro.RMSLE.early <-sqrt(mean((log10(level2tab.early$Conc.pred[
  level2tab.early$QSAR=="HTTK-InVitro"]/
  level2tab.early$Conc.obs[level2tab.early$QSAR=="HTTK-InVitro"]))^2,na.rm=TRUE))
OPERA.RMSLE.early <-sqrt(mean((log10(level2tab.early$Conc.pred[
  level2tab.early$QSAR=="HTTK-OPERA"]/
  level2tab.early$Conc.obs[level2tab.early$QSAR=="HTTK-OPERA"]))^2,na.rm=TRUE))
Pradeep.RMSLE.early <-sqrt(mean((log10(level2tab.early$Conc.pred[
  level2tab.early$QSAR=="HTTK-Pradeep"]/
  level2tab.early$Conc.obs[level2tab.early$QSAR=="HTTK-Pradeep"]))^2,na.rm=TRUE))
fits.RMSLE.early <-sqrt(mean((log10(level2tab.early$Conc.pred[
  level2tab.early$QSAR=="FitsToData"]/
  level2tab.early$Conc.obs[level2tab.early$QSAR=="FitsToData"]))^2,na.rm=TRUE))


ADMet.RMSLE.late <-sqrt(mean((log10(level2tab.late$Conc.pred[
  level2tab.late$QSAR=="HTTK-ADmet"]/
  level2tab.late$Conc.obs[level2tab.late$QSAR=="HTTK-ADmet"]))^2,na.rm=TRUE))
Dawson.RMSLE.late <-sqrt(mean((log10(level2tab.late$Conc.pred[
  level2tab.late$QSAR=="HTTK-Dawson"]/
  level2tab.late$Conc.obs[level2tab.late$QSAR=="HTTK-Dawson"]))^2,na.rm=TRUE))
InVitro.RMSLE.late <-sqrt(mean((log10(level2tab.late$Conc.pred[
  level2tab.late$QSAR=="HTTK-InVitro"]/
  level2tab.late$Conc.obs[level2tab.late$QSAR=="HTTK-InVitro"]))^2,na.rm=TRUE))
OPERA.RMSLE.late <-sqrt(mean((log10(level2tab.late$Conc.pred[
  level2tab.late$QSAR=="HTTK-OPERA"]/
  level2tab.late$Conc.obs[level2tab.late$QSAR=="HTTK-OPERA"]))^2,na.rm=TRUE))
Pradeep.RMSLE.late <-sqrt(mean((log10(level2tab.late$Conc.pred[
  level2tab.late$QSAR=="HTTK-Pradeep"]/
  level2tab.late$Conc.obs[level2tab.late$QSAR=="HTTK-Pradeep"]))^2,na.rm=TRUE))
fits.RMSLE.late <-sqrt(mean((log10(level2tab.late$Conc.pred[
  level2tab.late$QSAR=="FitsToData"]/
  level2tab.late$Conc.obs[level2tab.late$QSAR=="FitsToData"]))^2,na.rm=TRUE))


ADMet.MRPE <- median(subset(level2tab,QSAR=="HTTK-ADmet")$RPE)
Dawson.MRPE <- median(subset(level2tab,QSAR=="HTTK-Dawson")$RPE)
InVitro.MRPE <- median(subset(level2tab,QSAR=="HTTK-InVitro")$RPE)
OPERA.MRPE <- median(subset(level2tab,QSAR=="HTTK-OPERA")$RPE)
Pradeep.MRPE <- median(subset(level2tab,QSAR=="HTTK-Pradeep")$RPE)
fits.MRPE <- median(subset(level2tab,QSAR=="FitsToData")$RPE)

ADMet.MRPE.early <- median(subset(level2tab.early,QSAR=="HTTK-ADmet")$RPE)
Dawson.MRPE.early <- median(subset(level2tab.early,QSAR=="HTTK-Dawson")$RPE)
InVitro.MRPE.early <- median(subset(level2tab.early,QSAR=="HTTK-InVitro")$RPE)
OPERA.MRPE.early <- median(subset(level2tab.early,QSAR=="HTTK-OPERA")$RPE)
Pradeep.MRPE.early <- median(subset(level2tab.early,QSAR=="HTTK-Pradeep")$RPE)
fits.MRPE.early <- median(subset(level2tab.early,QSAR=="FitsToData")$RPE)

ADMet.MRPE.late <- median(subset(level2tab.late,QSAR=="HTTK-ADmet")$RPE)
Dawson.MRPE.late <- median(subset(level2tab.late,QSAR=="HTTK-Dawson")$RPE)
InVitro.MRPE.late <- median(subset(level2tab.late,QSAR=="HTTK-InVitro")$RPE)
OPERA.MRPE.late <- median(subset(level2tab.late,QSAR=="HTTK-OPERA")$RPE)
Pradeep.MRPE.late <- median(subset(level2tab.late,QSAR=="HTTK-Pradeep")$RPE)
fits.MRPE.late <- median(subset(level2tab.late,QSAR=="FitsToData")$RPE)


stats.table<-do.call("rbind",list(
# AAFE
  c(round(ADMet.AAFE,2),
    round(Dawson.AAFE,2),
    round(InVitro.AAFE,2),
    round(OPERA.AAFE,2),
    round(Pradeep.AAFE,2),
    round(fits.AAFE,2)),
# RMSLE
  c(round(ADMet.RMSLE,2),
    round(Dawson.RMSLE,2),
    round(InVitro.RMSLE,2),
    round(OPERA.RMSLE,2),
    round(Pradeep.RMSLE,2),
    round(fits.RMSLE,2)),
# MRPE 
    c(round(ADMet.MRPE,2),
    round(Dawson.MRPE,2),
    round(InVitro.MRPE,2),
    round(OPERA.MRPE,2),
    round(Pradeep.MRPE,2),
    round(fits.MRPE,2)),
# RMSLE.early
    c(round(ADMet.RMSLE.early,2),
    round(Dawson.RMSLE.early,2),
    round(InVitro.RMSLE.early,2),
    round(OPERA.RMSLE.early,2),
    round(Pradeep.RMSLE.early,2),
    round(fits.RMSLE.early,2)),
# RMSLE.late
    c(round(ADMet.RMSLE.late,2),
    round(Dawson.RMSLE.late,2),
    round(InVitro.RMSLE.late,2),
    round(OPERA.RMSLE.late,2),
    round(Pradeep.RMSLE.late,2),
    round(fits.RMSLE.late,2)),
# AAFE.early
  c(round(ADMet.AAFE.early,2),
    round(Dawson.AAFE.early,2),
    round(InVitro.AAFE.early,2),
    round(OPERA.AAFE.early,2),
    round(Pradeep.AAFE.early,2),
    round(fits.AAFE.early,2)),
# AAFE.late
    c(round(ADMet.AAFE.late,2),
    round(Dawson.AAFE.late,2),
    round(InVitro.AAFE.late,2),
    round(OPERA.AAFE.late,2),
    round(Pradeep.AAFE.late,2),
    round(fits.AAFE.late,2)),
# MRPE.early
  c(round(ADMet.MRPE.early,2),
    round(Dawson.MRPE.early,2),
    round(InVitro.MRPE.early,2),
    round(OPERA.MRPE.early,2),
    round(Pradeep.MRPE.early,2),
    round(fits.MRPE.early,2)),
# MRPE.late
  c(round(ADMet.MRPE.late,2),
    round(Dawson.MRPE.late,2),
    round(InVitro.MRPE.late,2),
    round(OPERA.MRPE.late,2),
    round(Pradeep.MRPE.late,2),
    round(fits.MRPE.late,2))
  ))
colnames(stats.table) <-  c("ADMet", "Dawson", "InVitro", "OPERA", "Pradeep","FitsToData")
rownames(stats.table) <- c("AAFE","RMSLE","MRPE","RMSLE.early","RMSLE.late","AAFE.early","AAFE.late","MRPE.early","MRPE.late")

AUC.stats.table <- NULL
for (this.qsar in unique(level2tab.stats$QSAR))
{
  this.subset <- subset(level2tab.stats,QSAR==this.qsar)
  this.fit <- lm(data=this.subset,AUC.obs~AUC.pred)
  this.row <- data.frame(
    this.qsar,
    R2=signif(summary(this.fit)$adj.r.squared,3),
    RMSE=signif(sqrt(mean(summary(this.fit)$residuals^2)),3)
    )
  AUC.stats.table <- rbind(AUC.stats.table,this.row)
}

Cmax.stats.table <- NULL
for (this.qsar in unique(level2tab.stats$QSAR))
{
  this.subset <- subset(level2tab.stats,QSAR==this.qsar)
  this.fit <- lm(data=this.subset,Cmax.obs~Cmax.pred)
  this.row <- data.frame(
    this.qsar,
    R2=signif(summary(this.fit)$adj.r.squared,3),
    RMSE=signif(sqrt(mean(summary(this.fit)$residuals^2)),3)
    )
  Cmax.stats.table <- rbind(Cmax.stats.table,this.row)
}

```

Heatmap with Level 2 stats
```{r make_heatmap, eval = TRUE}
CvT.chems.stats.heatmap <- CvT.chems.scale
for (this.qsar in unique(level2tab.stats$QSAR))
{
  this.subset <- subset(level2tab.stats,QSAR==this.qsar)
  print(paste(this.qsar,length(unique(this.subset$Compound))))
  for (this.chem in unique(this.subset$DTXSID))
  {
    this.subset2 <- subset(this.subset,DTXSID==this.chem)
    this.index <- tolower(CvT.chems.stats.heatmap$DTXSID)==tolower(this.chem)
    CvT.chems.stats.heatmap[this.index,paste("AUC.RPE",this.qsar,sep=".")] <- 
      mean(this.subset2$AUC.RPE)
    CvT.chems.stats.heatmap[this.index,paste("Cmax.RPE",this.qsar,sep=".")] <- 
      mean(this.subset2$Cmax.RPE)
    this.subset3 <- subset(level2tab, QSAR==this.qsar & DTXSID==this.chem)
    CvT.chems.stats.heatmap[this.index,paste("RMSLE",this.qsar,sep=".")] <- 
      mean(log10(this.subset3$Conc.obs/this.subset3$Conc.pred)^2)^(1/2)
    if (is.na(CvT.chems.stats.heatmap[this.index,paste("RMSLE",this.qsar,sep=".")])) browser()
  }
}
```

```{r scale_preds, eval = TRUE}
for (this.chem in CvT.chems.stats.heatmap$PREFERRED_NAME) 
{
#print(this.chem)
  this.index <- which(CvT.chems.stats.heatmap$PREFERRED_NAME==this.chem)
  v <- unlist(CvT.chems.stats.heatmap[this.index, regexpr("AUC.RPE",
    colnames(CvT.chems.stats.heatmap))!=-1])
#  print(v)
  if (any(!is.na(v)))
  {
    m <- mean(v,na.rm=TRUE)
    s <- sd(v,na.rm=TRUE)
    CvT.chems.stats.heatmap[this.index, regexpr("AUC.RPE",
      colnames(CvT.chems.stats.heatmap))!=-1] <- 
      (v - m)/s
  }
  v <- unlist(CvT.chems.stats.heatmap[this.index, regexpr("Cmax.RPE",
    colnames(CvT.chems.stats.heatmap))!=-1])
  #print(v)
  if (any(!is.na(v)))
  {
    m <- mean(v,na.rm=TRUE)
    s <- sd(v,na.rm=TRUE)
  CvT.chems.stats.heatmap[this.index, regexpr("Cmax.RPE",
    colnames(CvT.chems.stats.heatmap))!=-1] <- 
    (v - m)/s
  }
  v <- unlist(CvT.chems.stats.heatmap[this.index, regexpr("RMSLE",
    colnames(CvT.chems.stats.heatmap))!=-1])
  #print(v)
  if (any(!is.na(v)))
  {
    m <- mean(v,na.rm=TRUE)
    s <- sd(v,na.rm=TRUE)
    CvT.chems.stats.heatmap[this.index, regexpr("RMSLE",
      colnames(CvT.chems.stats.heatmap))!=-1] <- 
      (v - m)/s
  }
}
```
```{r make_stats_heatmap, eval = TRUE}
mypalette<-brewer.pal(11,"RdYlBu")
  heatmap.2(as.matrix(CvT.chems.stats.heatmap[,4:39]),
    lwid=c(0.4,1),
    lhei=c(0.4,1),
    margins=c(10,1),
    labRow = FALSE,
    cexCol=1,
    trace="none",
    col=mypalette)
```


```{r make_level2_plot_stats, eval = TRUE}
#### add AAFE & RMSLE to the table
texty <- 1
xshift <- 0.1
FigLev2 <- ggplot(data=level2tab, aes(x=QSAR, y=RPE)) + 
    geom_hline(yintercept=0,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
#  scale_y_log10(label=scientific_10,limits=c(10^-2,10^4))+
  geom_boxplot(lwd=0.3,
               outlier.shape = NA)+
 # Pradeep NEW coord_cartesian(ylim=c(-30,210))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  coord_cartesian(ylim=c(-1,2))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
    xlab("QSAR") +
  ylab(bquote("Relative Error for In Vivo CvT Data"))+
  theme_bw()+
  annotation_custom(tableGrob(c("AAFE","RMSLE"), theme = ttheme_minimal(base_size = 12)),
                    xmin=0,xmax=1.2+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE","RMSLE"),"FitsToData"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=2.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE","RMSLE"),"ADMet"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=4.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE","RMSLE"),"Dawson"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=6.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE","RMSLE"),"InVitro"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=8.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE","RMSLE"),"OPERA"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=10.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE","RMSLE"),"Pradeep"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=12.3+xshift,ymin=(texty-1),ymax=texty)+
  theme( text  = element_text(size=20),
  legend.key.height=unit(.5,"line"),
  legend.text=element_text(size=14),
  legend.title = element_text(size=14),
  axis.text.x = element_text(angle = 45, vjust = 0.5, size=14),
  axis.title.y=element_text(size=12))
print(FigLev2) 
#ggsave(paste("figs/FigLev2_boxplot_trunc_PradeepNEW",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)
ggsave(paste("figs/FigLev2_boxplot_trunc",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)
```

```{r make_level2_plot_stats_early, eval = TRUE}
#### add AAFE & RMSLE to the table
texty <- 1
xshift <- 0.1
FigLev2 <- ggplot(data=level2tab.early, aes(x=QSAR, y=RPE)) + 
    geom_hline(yintercept=0,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
#  scale_y_log10(label=scientific_10,limits=c(10^-2,10^4))+
  geom_boxplot(lwd=0.3,
               outlier.shape = NA)+
 # Pradeep NEW coord_cartesian(ylim=c(-30,210))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  coord_cartesian(ylim=c(-1,2))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
    xlab("QSAR") +
  ylab(bquote("Relative Error for In Vivo CvT Data"))+
  theme_bw()+
  annotation_custom(tableGrob(c("AAFE","RMSLE"), theme = ttheme_minimal(base_size = 12)),
                    xmin=0,xmax=1.2+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.early","RMSLE.early"),"FitsToData"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=2.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.early","RMSLE.early"),"ADMet"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=4.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.early","RMSLE.early"),"Dawson"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=6.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.early","RMSLE.early"),"InVitro"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=8.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.early","RMSLE.early"),"OPERA"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=10.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.early","RMSLE.early"),"Pradeep"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=12.3+xshift,ymin=(texty-1),ymax=texty)+
  theme( text  = element_text(size=20),
  legend.key.height=unit(.5,"line"),
  legend.text=element_text(size=14),
  legend.title = element_text(size=14),
  axis.text.x = element_text(angle = 45, vjust = 0.5, size=14),
  axis.title.y=element_text(size=12))
print(FigLev2) 
#ggsave(paste("figs/FigLev2_boxplot_trunc_PradeepNEW",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)
ggsave(paste("figs/FigLev2_boxplot_trunc",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)
```

```{r make_level2_plot_stats_late, eval = TRUE}
#### add AAFE & RMSLE to the table
texty <- 1
xshift <- 0.1
FigLev2 <- ggplot(data=level2tab.late, aes(x=QSAR, y=RPE)) + 
    geom_hline(yintercept=0,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
#  scale_y_log10(label=scientific_10,limits=c(10^-2,10^4))+
  geom_boxplot(lwd=0.3,
               outlier.shape = NA)+
 # Pradeep NEW coord_cartesian(ylim=c(-30,210))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  coord_cartesian(ylim=c(-1,2))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
    xlab("QSAR") +
  ylab(bquote("Relative Error for In Vivo CvT Data"))+
  theme_bw()+
  annotation_custom(tableGrob(c("AAFE","RMSLE"), theme = ttheme_minimal(base_size = 12)),
                    xmin=0,xmax=1.2+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.late","RMSLE.early"),"FitsToData"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=2.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.late","RMSLE.early"),"ADMet"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=4.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.late","RMSLE.early"),"Dawson"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=6.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.late","RMSLE.early"),"InVitro"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=8.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.late","RMSLE.early"),"OPERA"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=10.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("AAFE.late","RMSLE.early"),"Pradeep"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=12.3+xshift,ymin=(texty-1),ymax=texty)+
  theme( text  = element_text(size=20),
  legend.key.height=unit(.5,"line"),
  legend.text=element_text(size=14),
  legend.title = element_text(size=14),
  axis.text.x = element_text(angle = 45, vjust = 0.5, size=14),
  axis.title.y=element_text(size=12))
print(FigLev2) 
#ggsave(paste("figs/FigLev2_boxplot_trunc_PradeepNEW",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)
ggsave(paste("figs/FigLev2_boxplot_trunc",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)
```

```{r make_level2_auc_plot, eval = TRUE}
FigLev2.auc <- ggplot(data=level2tab.stats, aes(x=QSAR, y=AUC.RPE)) + 
#  geom_hline(yintercept=1,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
  geom_boxplot(outlier.colour="red",
    outlier.size=2,
    outlier.alpha=0.1)+
  xlab("QSAR") +
  ylab("RPE for In Vivo CvTdb AUC")+
  scale_y_continuous(limits=c(-1.5,3)) +
#  scale_y_log10(limits=c(10^-1,10),breaks=c(10^-2,10^-1,1,3,10,10^2,10^3),label=scientific_10)+
  theme_bw()+
  theme( text  = element_text(size=20))   +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
print(FigLev2.auc)  
```

```{r make_level2_auc_plot, eval = TRUE}
FigLev2AUC_facet <- ggplot(data=level2tab.stats) +
  geom_point(size=2,aes(x=AUC.pred,y=AUC.obs,shape=QSAR,color=QSAR))+
  scale_x_log10(breaks=c(10^-5,10^-2,10),label=scientific_10,limits=c(10^-7,3000)) +
  #scale_y_log10(label=scientific_10)+
  scale_y_log10(breaks=c(10^-1,1,10,10^2),label=scientific_10,limits = c(30^-1, 300))+
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="black",size=0.2) +
  #geom_abline(intercept = log10(3), slope = 1,linetype="dotted", colour="gray") +
  #geom_abline(intercept = -log10(3), slope = 1,linetype="dotted", colour="gray") +
  geom_abline(intercept = 1, slope = 1,linetype="dashed", colour="gray66",size=0.3) +
  geom_abline(intercept = -1, slope = 1,linetype="dashed", colour="gray66",size=0.3) +
  xlab('Predicted AUC (mg/L*h)') +
  ylab('Observed AUC (mg/L*h)') +
  theme_bw()+
  facet_grid(cols=vars(QSAR))+
  theme( text  = element_text(size=20),
         legend.position = "none",
         strip.text.x = element_text(size = 10),
         axis.title = element_text(size=20),
         axis.text.x = element_text(size=10))

print(FigLev2AUC_facet)
print(AUC.stats.table)
```

```{r make_level2_auc_plot, eval = TRUE}
FigLev2.auc <- ggplot(data=level2tab.stats, aes(x=QSAR, y=AUC.RPE)) + 
#  geom_hline(yintercept=1,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
  geom_boxplot(outlier.colour="red",
    outlier.size=2,
    outlier.alpha=0.1)+
  xlab("QSAR") +
  ylab("RPE for In Vivo CvTdb AUC")+
  scale_y_continuous(limits=c(-1.5,3)) +
#  scale_y_log10(limits=c(10^-1,10),breaks=c(10^-2,10^-1,1,3,10,10^2,10^3),label=scientific_10)+
  theme_bw()+
  theme( text  = element_text(size=20))   +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
print(FigLev2.auc)  
```

```{r make_level2_cmax_plot, eval = TRUE}
FigLev2.cmax <- ggplot(data=level2tab.stats, aes(x=QSAR, y=Cmax.RPE)) + 
#  geom_hline(yintercept=1,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
  geom_boxplot(outlier.colour="red",
    outlier.size=2,
    outlier.alpha=0.1)+
  xlab("QSAR") +
  ylab("RPE for In Vivo CvTdb Cmax")+
  scale_y_continuous(limits=c(-1.5,3)) +
 # scale_y_log10(breaks=c(10^-2,10^-1,1,3,10,10^2,10^3),label=scientific_10)+
  theme_bw()+
  theme( text  = element_text(size=20))   +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
print(FigLev2.cmax)  
```
```{r make_level2_plot, eval = TRUE}
FigLev2 <- ggplot(data=level2tab, aes(x=QSAR, y=RPE)) + 
#  geom_hline(yintercept=1,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
  geom_boxplot(outlier.colour="red",
    outlier.size=2,
    outlier.alpha=0.1)+
  xlab("QSAR") +
  ylab("RPE for In Vivo CvT Data")+
 # scale_y_continuous(limits=c(-10,40)) +
 # scale_y_log10(limits=c(10-2,100),breaks=c(10^-1,1,3,10),label=scientific_10)+
  theme_bw()+
  theme( text  = element_text(size=20))   +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))+
  theme(axis.title.y = element_text(size=18))
print(FigLev2)  
```

```{r make_level2_cmax_plot, eval = TRUE}
FigLev2Cmax_facet <- ggplot(data=level2tab.stats) +
  geom_point(size=2,aes(x=Cmax.pred,y=Cmax.obs,shape=QSAR,color=QSAR))+
  scale_x_log10(breaks=c(10^-5,10^-2,10^1),label=scientific_10,limits=c(10^-7,3000)) +
  #scale_y_log10(label=scientific_10)+
  scale_y_log10(breaks=c(10^-1,1,10,10^2),label=scientific_10,limits = c(30^-1, 300))+
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="black",size=0.2) +
  #geom_abline(intercept = log10(3), slope = 1,linetype="dotted", colour="gray") +
  #geom_abline(intercept = -log10(3), slope = 1,linetype="dotted", colour="gray") +
  geom_abline(intercept = 1, slope = 1,linetype="dashed", colour="gray66",size=0.3) +
  geom_abline(intercept = -1, slope = 1,linetype="dashed", colour="gray66",size=0.3) +
  xlab(bquote('Predicted'~C[max]~'(mg/L)')) +
  ylab(bquote('Observed'~C[max]~'(mg/L)')) +
  theme_bw()+
  facet_grid(cols=vars(QSAR))+
  theme( text  = element_text(size=20),
         legend.position = "none",
         strip.text.x = element_text(size = 10),
         axis.title = element_text(size=20),
         axis.text.x = element_text(size=10))

print(FigLev2Cmax_facet)

print(Cmax.stats.table)
```


```{r make_RMSE_bychem_analysis, eval = TRUE}
qsarbychem.table <- NULL
QSARs <- unique(level2tab$QSAR)
for (this.chemical in unique(level2tab$Compound))
{
  for (this.qsar in QSARs)
  {
    this.subset <- subset(level2tab,QSAR==this.qsar & Compound==this.chemical)
    this.row <- this.subset[1,c(1:3,13)]
    this.row$RMSLE <- sqrt(mean((log10(this.subset$Conc.pred/
      this.subset$Conc.obs))^2,na.rm=TRUE))
    this.subset <- subset(level2tab.early,QSAR==this.qsar & Compound==this.chemical)
    this.row$RMSLE.early <- sqrt(mean((log10(this.subset$Conc.pred/
      this.subset$Conc.obs))^2,na.rm=TRUE))
    this.subset <- subset(level2tab.late,QSAR==this.qsar & Compound==this.chemical)
    this.row$RMSLE.late <- sqrt(mean((log10(this.subset$Conc.pred/
      this.subset$Conc.obs))^2,na.rm=TRUE))
    qsarbychem.table <- rbind(qsarbychem.table,this.row)
  }                    
}
```
```{r make_RMSE_bychem_plot, eval = TRUE}
#### add AAFE & RMSLE to the table
texty <- 2.5
xshift <- 0.2
FigLev2RMSE <- ggplot(data=qsarbychem.table, aes(x=QSAR, y=RMSLE)) + 
    geom_hline(yintercept=0,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
#  scale_y_log10(label=scientific_10,limits=c(10^-2,10^4))+
  geom_boxplot(lwd=0.3,
               outlier.shape = NA)+
 # Pradeep NEW coord_cartesian(ylim=c(-30,210))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  coord_cartesian(ylim=c(-0.5,2.5))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
    xlab("QSAR") +
  ylab(bquote("Chemical-Specific RMSLE for In Vivo CvT Data"))+
  theme_bw()+
  annotation_custom(tableGrob(c("RMSLE","AAFE"), theme = ttheme_minimal(base_size = 12)),
                    xmin=0,xmax=1.2+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE","AAFE"),"FitsToData"], theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=2.3+xshift,ymin=(texty-1),ymax=texty)+
annotation_custom(tableGrob(stats.table[c("RMSLE","AAFE"),"ADMet"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=4.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE","AAFE"),"Dawson"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=6.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE","AAFE"),"InVitro"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=8.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE","AAFE"),"OPERA"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=10.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE","AAFE"),"Pradeep"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=12.3+xshift,ymin=(texty-1),ymax=texty)+
  theme( text  = element_text(size=20),
  legend.key.height=unit(.5,"line"),
  legend.text=element_text(size=14),
  legend.title = element_text(size=14),
  axis.text.x = element_text(angle = 45, vjust = 0.5, size=14),
  axis.title.y=element_text(size=10))
print(FigLev2RMSE) 
```
```{r make_RMSE_bychem_early_plot, eval = TRUE}
#### add AAFE & RMSLE to the table
texty <- 2.5
xshift <- 0.2
FigLev2RMSE.early <- ggplot(data=qsarbychem.table, aes(x=QSAR, y=RMSLE.early)) +
   ggtitle("Early Time Points")+
    geom_hline(yintercept=0,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
#  scale_y_log10(label=scientific_10,limits=c(10^-2,10^4))+
  geom_boxplot(lwd=0.3,
               outlier.shape = NA)+
 # Pradeep NEW coord_cartesian(ylim=c(-30,210))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  coord_cartesian(ylim=c(-0.5,2.5))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
    xlab("QSAR") +
  ylab(bquote("Chemical-Specific RMSLE for In Vivo CvT Data"))+
  theme_bw()+
  annotation_custom(tableGrob(c("RMSLE","AAFE"), theme = ttheme_minimal(base_size = 12)),
                    xmin=0,xmax=1.2+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE.early","AAFE.early"),"FitsToData"], theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=2.3+xshift,ymin=(texty-1),ymax=texty)+
annotation_custom(tableGrob(stats.table[c("RMSLE.early","AAFE.early"),"ADMet"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=4.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE.early","AAFE.early"),"Dawson"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=6.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE.early","AAFE.early"),"InVitro"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=8.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE.early","AAFE.early"),"OPERA"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=10.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE.early","AAFE.early"),"Pradeep"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=12.3+xshift,ymin=(texty-1),ymax=texty)+
  theme( text  = element_text(size=20),
  legend.key.height=unit(.5,"line"),
  legend.text=element_text(size=14),
  legend.title = element_text(size=14),
  axis.text.x = element_text(angle = 45, vjust = 0.5, size=14),
  axis.title.y=element_text(size=10))
print(FigLev2RMSE.early) 
```
```{r make_RMSE_bychem_late_plot, eval = TRUE}
#### add AAFE & RMSLE to the table
texty <- 2.5
xshift <- 0.2
FigLev2RMSE.late <- ggplot(data=qsarbychem.table, aes(x=QSAR, y=RMSLE.late)) +
   ggtitle("Late Time Points")+
    geom_hline(yintercept=0,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
  #  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
#  scale_y_log10(label=scientific_10,limits=c(10^-2,10^4))+
  geom_boxplot(lwd=0.3,
               outlier.shape = NA)+
 # Pradeep NEW coord_cartesian(ylim=c(-30,210))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
  coord_cartesian(ylim=c(-0.5,2.5))+ ### !!!!!!! "coord" does NOT alter the data if data points are removed. "scale" does
    xlab("QSAR") +
  ylab(bquote("Chemical-Specific RMSLE for In Vivo CvT Data"))+
  theme_bw()+
  annotation_custom(tableGrob(c("RMSLE","AAFE"), theme = ttheme_minimal(base_size = 12)),
                    xmin=0,xmax=1.2+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE.late","AAFE.late"),"FitsToData"], theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=2.3+xshift,ymin=(texty-1),ymax=texty)+
annotation_custom(tableGrob(stats.table[c("RMSLE.late","AAFE.late"),"ADMet"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=4.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE.late","AAFE.late"),"Dawson"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=6.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE.late","AAFE.late"),"InVitro"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=8.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE.late","AAFE.late"),"OPERA"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=10.3+xshift,ymin=(texty-1),ymax=texty)+
  annotation_custom(tableGrob(stats.table[c("RMSLE.late","AAFE.late"),"Pradeep"],rows=NULL, theme = ttheme_minimal(base_size = 14)),
                    xmin=0,xmax=12.3+xshift,ymin=(texty-1),ymax=texty)+
  theme( text  = element_text(size=20),
  legend.key.height=unit(.5,"line"),
  legend.text=element_text(size=14),
  legend.title = element_text(size=14),
  axis.text.x = element_text(angle = 45, vjust = 0.5, size=14),
  axis.title.y=element_text(size=10))
print(FigLev2RMSE.late) 
```


```{r analyze_admet1,eval=TRUE}
admet.better <-NULL
invitro.better <-NULL
for (this.cas in unique(level2tab$CAS))
{
  this.subset1 <- subset(level2tab,CAS==this.cas)
  for (this.source in unique(this.subset1$Source))
  {
    this.subset2 <- subset(this.subset1,Source==this.source)  
    for (this.time in unique(this.subset2$Time))
    {
      this.subset3 <- subset(this.subset2,Time==this.time)
      this.subset3.invitro <- subset(this.subset3, QSAR=="HTTK-InVitro")
      this.subset3.admet <- subset(this.subset3, QSAR=="HTTK-ADmet")
      this.subset3 <- cbind(this.subset3.invitro,
        this.subset3.admet[,c("Conc.pred","RPE","AbsFE")])
      colnames(this.subset3)[16:18] <- paste(
        colnames(this.subset3)[16:18],"ADmet",sep=".")
      admet.better <- rbind(admet.better,
        subset(this.subset3,abs(RPE.ADmet) < abs(RPE)))
      invitro.better <- rbind(invitro.better,
        subset(this.subset3,abs(RPE.ADmet) > abs(RPE)))
    }
  }
}
admet.chems <- unique(admet.better$Compound)
invitro.chems <- unique(invitro.better$Compound)
admet.chems[!(admet.chems %in% invitro.chems)]
admet.better.chems <- admet.chems[!(admet.chems %in% invitro.chems)]
invitro.better.chems <- invitro.chems[!(invitro.chems %in% admet.chems)]

admet.better.data <- subset(CvT.chems,PREFERRED_NAME%in%admet.better.chems)
invitro.better.data <- subset(CvT.chems,PREFERRED_NAME%in%invitro.better.chems)


dev.new()
plot(admet.better.data$Human.Fup.httk,admet.better.data$Human.Fup.SPlus)
plot(admet.better.data$Human.Clint.httk+10^-3,admet.better.data$Human.Clint.SPlus+10^-3,log="xy")

```
      


Need to do invivo vs invitro/insilco plots for AUC & Cmax
Need heatmap of RMSE x chemical, can add phys-chem
```{r analyze_admet, eval = TRUE}
qsarbychem.table2 <- dcast(qsarbychem.table,Compound~QSAR,value.var="RMSLE")
chems <- qsarbychem.table2$Compound
qsarbychem.table2 <- apply(qsarbychem.table2[,2:(1+length(QSARs))],2,as.numeric)
rownames(qsarbychem.table2) <- chems
colnames(qsarbychem.table2) <- c("FitsToData","ADmet","Dawson","InVitro","OPERA","Pradeep")
```

```{r make_rmse_heatmap, eval = TRUE}




  mypalette<-brewer.pal(9,"PuRd")
  heatmap.2(t(qsarbychem.table2),
 #   lwid=c(0.3,1),
#    lhei=c(0.3,1),
    margins=c(10,8),
#    labRow = FALSE,
    cexCol=0.25,
    cexRow=1.0,
    trace="none",
    col=mypalette)
```
```{r model_admet_difference, eval = TRUE}
for (this.chem in unique(rownames(qsarbychem.table2)))
{
  DTXSID <- level2tab[level2tab$Compound==this.chem,"DTXSID"][1]
  CvT.chems.nona[CvT.chems.nona$DTXSID == DTXSID, "ADMetDiff"] <-
    qsarbychem.table2[this.chem,"ADmet"] - 
    qsarbychem.table2[this.chem,"InVitro"]
}
thresh <- 0.2
admetdiff <- subset(CvT.chems.nona,!is.na(ADMetDiff))
  admetdiff[admetdiff$ADMetDiff > thresh, "ADMetDiffCat"]<-3
  admetdiff[admetdiff$ADMetDiff < (-thresh), "ADMetDiffCat"]<-1
  admetdiff[admetdiff$ADMetDiff > (-thresh) &
    admetdiff$ADMetDiff < thresh, "ADMetDiffCat"]<-2

# Add 1 vs. 2 comp:
admetdiff <- merge(admetdiff,fittable[,c(1,4)],by.x="CASRN",by.y="CAS")
  
# Add enzymes:
for (this.chem in admetdiff$DTXSID)
  if (this.chem %in% cyps$DTXSID)
  {
    this.subset <- subset(cyps,DTXSID==this.chem)
    for (this.cyp in this.subset$ISOFORM)
    {
      admetdiff[admetdiff$DTXSID==this.chem,this.cyp] <- "1"
    }
  }
for (this.col in 25:31) admetdiff[is.na(admetdiff[,this.col]),this.col] <- 0


dat <- admetdiff[,c(4:15,22,24:31)]

# Turn into factor:
for (this.col in 14:21) dat[,this.col] <- as.factor(dat[,this.col])
  
# Add contrast between ADmet and HTTK 
dat$Clint.Ratio <- dat$Human.Clint.SPlus/dat$Human.Clint.httk
dat$Clint.Ratio[is.nan(dat$Clint.Ratio)] <- 1
dat$Clint.Ratio[!is.finite(dat$Clint.Ratio)] <- 10000

dat$Fup.Ratio <- dat$Human.Fup.SPlus/dat$Human.Fup.httk
dat$Fup.Ratio[is.nan(dat$Fup.Ratio)] <- 1

library(randomForest)
colnames(dat)[1] <- "Molecular_Weight"
colnames(dat)[2] <- "Boiling_Point"
colnames(dat)[3] <- "Henrys_Law_Constant"
colnames(dat)[4] <- "LogKow"
colnames(dat)[5] <- "LogKoa"
colnames(dat)[6] <- "Melting_Point"
colnames(dat)[7] <- "Vapor_Pressure"
colnames(dat)[8] <- "Water_Solubility"
#dat$ADMetDiff <-as.factor(dat$ADMetDiff)
this.rf <- randomForest(data=dat,ADMetDiff ~ .,sample=c(15,15,15),ntree=5000)
print(this.rf)
varImpPlot(this.rf)
plot(dat[,2],dat[,13])
```


  
  


                  
# Not sure if we can reasonably show all the predictions vs. the observations.
# Maybe one plot per model?
# FigLev2a <- ggplot(data=level2tab) +
#  geom_point(size=3,alpha=0.01,aes(x=Conc.pred.trunc,y=Conc.obs.trunc,shape=QSAR,color=QSAR))+
#  scale_x_log10(label=scientific_10) +
#  scale_y_log10(label=scientific_10)+
#    geom_abline(intercept = 0, slope = 1,linetype="dashed", colour="Blue") +
#  xlab(bquote('Predicted'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
#  ylab(bquote('Observed'~Cl[int]~"("*mu*"L/min/"*10^6~"hep.)")) +
#  theme_bw()+
#  theme( text  = element_text(size=20))
# print(FigLev2a)

```{r make_pred_vs_obs_plots, eval = TRUE}
FigLev2a <- ggplot(data=level2tab[level2tab$QSAR=="HTTK-InVitro",]) +
 geom_point(size=.75,alpha=0.05,aes(x=Conc.pred,y=Conc.obs))+
 scale_x_log10(breaks=10^seq(-5,4,by=2),label=scientific_10) +
 scale_y_log10(breaks=10^seq(-5,4,by=2),label=scientific_10)+
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="black",size=0.3) +
  # geom_abline(intercept = log10(3), slope = 1,linetype="dotted", colour="gray") +
  #geom_abline(intercept = -log10(3), slope = 1,linetype="dotted", colour="gray") +
  geom_abline(intercept = 1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
  geom_abline(intercept = -1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
 xlab(bquote('HTTK-InVitro')) +
 ylab(bquote(' ')) +
 theme_bw()+
 theme( text  = element_text(size=20),
         axis.text.y = element_text(size=10))
#print(FigLev2a)
ggsave(paste("figs/FigLev2_Conc_scatter_HTTKInVitro",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)

FigLev2b <- ggplot(data=level2tab[level2tab$QSAR=="HTTK-ADmet",]) +
  geom_point(size=.75,alpha=0.05,aes(x=Conc.pred,y=Conc.obs))+
  scale_x_log10(breaks=10^seq(-5,4,by=2),label=scientific_10) +
  scale_y_log10(breaks=10^seq(-5,4,by=2),label=scientific_10)+
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="black",size=0.3) +
  # geom_abline(intercept = log10(3), slope = 1,linetype="dotted", colour="gray") +
  #geom_abline(intercept = -log10(3), slope = 1,linetype="dotted", colour="gray") +
  geom_abline(intercept = 1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
  geom_abline(intercept = -1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
  xlab(bquote('HTTK-ADMET')) +
  ylab(bquote(' ')) +
  theme_bw()+
  theme( text  = element_text(size=20),
         axis.text.y = element_text(size=10))
#print(FigLev2b)
ggsave(paste("figs/FigLev2_Conc_scatter_HTTKADmet",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)

FigLev2c <- ggplot(data=level2tab[level2tab$QSAR=="HTTK-Pradeep",]) +
  geom_point(size=.75,alpha=0.05,aes(x=Conc.pred,y=Conc.obs))+
  scale_x_log10(breaks=10^seq(-5,4,by=2),label=scientific_10) +
  scale_y_log10(breaks=10^seq(-5,4,by=2),label=scientific_10)+
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="black",size=0.3) +
  # geom_abline(intercept = log10(3), slope = 1,linetype="dotted", colour="gray") +
  #geom_abline(intercept = -log10(3), slope = 1,linetype="dotted", colour="gray") +
  geom_abline(intercept = 1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
  geom_abline(intercept = -1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
  #  xlab(bquote('Predicted Conc HTTK-PradeepNEW')) +  ##Pradeep NEW ##
  xlab(bquote('HTTK-Pradeep')) +
  ylab(bquote('Observed Conc In Vivo')) +
  theme_bw()+
  theme( text  = element_text(size=20),
         axis.title.y = element_text(size=14),
         axis.text.y = element_text(size=10))
#print(FigLev2c)
#ggsave(paste("figs/FigLev2_Conc_scatter_HTTKPradeepNEW",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)
ggsave(paste("figs/FigLev2_Conc_scatter_HTTKPradeep",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)


FigLev2d <- ggplot(data=level2tab[level2tab$QSAR=="HTTK-Dawson",]) +
  geom_point(size=.75,alpha=0.05,aes(x=Conc.pred,y=Conc.obs))+
  scale_x_log10(breaks=10^seq(-5,4,by=2),label=scientific_10) +
  scale_y_log10(breaks=10^seq(-5,4,by=2),label=scientific_10)+
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="black",size=0.3) +
  # geom_abline(intercept = log10(3), slope = 1,linetype="dotted", colour="gray") +
  #geom_abline(intercept = -log10(3), slope = 1,linetype="dotted", colour="gray") +
  geom_abline(intercept = 1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
  geom_abline(intercept = -1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
  xlab(bquote('HTTK-Dawson')) +
  ylab(bquote(' ')) +
  theme_bw()+
  theme( text  = element_text(size=20),
         axis.text.y = element_text(size=10))
#print(FigLev2d)
ggsave(paste("figs/FigLev2_Conc_scatter_HTTKDawson",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)

FigLev2e <- ggplot(data=level2tab[level2tab$QSAR=="HTTK-OPERA" ,]) +
  geom_point(size=.75,alpha=0.05,aes(x=Conc.pred,y=Conc.obs))+
  scale_x_log10(breaks=10^seq(-5,4,by=2),label=scientific_10) +
  scale_y_log10(breaks=10^seq(-5,4,by=2),label=scientific_10)+
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="black",size=0.3) +
  # geom_abline(intercept = log10(3), slope = 1,linetype="dotted", colour="gray") +
  #geom_abline(intercept = -log10(3), slope = 1,linetype="dotted", colour="gray") +
  geom_abline(intercept = 1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
  geom_abline(intercept = -1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
  xlab(bquote('HTTK-OPERA')) +
  ylab(bquote(' ')) +
  theme_bw()+
  theme( text  = element_text(size=20),
         axis.text.y = element_text(size=10))
#print(FigLev2e)
ggsave(paste("figs/FigLev2_Conc_scatter_HTTKOPERA",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)

FigLev2f <- ggplot(data=level2tab[level2tab$QSAR=="FitsToData" ,]) +
  geom_point(size=.75,alpha=0.05,aes(x=Conc.pred,y=Conc.obs))+
  scale_x_log10(breaks=10^seq(-5,4,by=2),label=scientific_10) +
  scale_y_log10(breaks=10^seq(-5,4,by=2),label=scientific_10)+
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="black",size=0.3) +
  # geom_abline(intercept = log10(3), slope = 1,linetype="dotted", colour="gray") +
  #geom_abline(intercept = -log10(3), slope = 1,linetype="dotted", colour="gray") +
  geom_abline(intercept = 1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
  geom_abline(intercept = -1, slope = 1,linetype="dashed", colour="gray22",size=0.3) +
  xlab(bquote('FitsToData')) +
  ylab(bquote(' ')) +
  theme_bw()+
  theme( text  = element_text(size=20),
         axis.text.y = element_text(size=10))
#print(FigLev2f)
ggsave(paste("figs/FigLev2_Conc_scatter_FitsToData",output.prefix,".tiff",sep=""), width=4, height=3, dpi=300)

grid.arrange(FigLev2a, FigLev2b, FigLev2c, FigLev2d, FigLev2e, FigLev2f, nrow = 3)
```

#Level III Predictions -- predicted half-life or volume of distribution (Vd)
# vs. estimates from CvT data (invivoPKfit)
# 
# Jon Arnot provide two models that directly predicted half-life. All the other
# QSAR values were used with HTTK to predict half-life and Vd. Hopefully we
# can also have Admet predict these values.
#
# As with level II, we can only compare the HTTK+in vitro measured preditions
# for a subset of the chemicals and to date I have lumped everything together.
# 
# Further complicating things, not every chemical in the evaluation set 
# permitted estimation
# of Vd and thalf. The optimizer had to be able to fine a maximimum likelihood
# estimate and it fails some of the time. The estimates we are using were made
# with invivoPKfit and published in Sayre et al. (2020)
#
# We have values for 83/100 chemicals. As with level II, when we make predictions

# Jon Arnot:
#We suggest using the QSARs for HUMAN total elimination half-life (HLT; hours) 
#as these are most relevant to the rodent time course data (half-lives/clearance)
# half-life (HLB; hours) predictions for possible comparisons. For each 
# prediction Alessandro has reported an indication of the AD (i.e. "OK" or 
# "Warning"), there are more explicit AD details available for all models, but 
# this provides a starting indication of expected prediction reliability.
#
#I have scaled the half-lives from 70 kg bw (assumed humans) to 0.25 kg bw for 
#typical rat body weight using a  bw allometric scaling factor.
#
#The human half-life QSARs are detailed in these publications:
#
#1.	IFS-QSAR Human HLB and HLT predictions:
#Arnot, J. A.; Brown, T. N.; Wania, F., Estimating screening-level organic 
#chemical half-lives in humans. Environ. Sci. Technol. 2014, 48, 723-730.
#2.	QSARINS Human HLB and HLT predictions:
#Papa, E.; Sangion, A.; Arnot, J. A.; Gramatica, P., Development of human 
#biotransformation QSARs and application for PBT assessment refinement. Food 
#Chem. Toxicol. 2018, 112, 535-543.
#
#We have also included Biotransformation HL in fish (hours) by QSARINS, IFS and 
#EPI suite models as well as that were used in the 
#training/testing sets. I don''t think they are as comparable to rodent data as 
#the human predictions, but they were developed with different training sets 
#(and for fish, not mammals!).
```{r do_level3, eval = TRUE}
level3.arnot <- read_excel("TK_QSAR_evaluation_set_HumanQSARHLPredictions.xlsx")
level3.arnot <- subset(level3.arnot,administration_route_normalized=="iv")
level3tab.arnot1 <- level3tab.opera
level3tab.arnot1$Vd.pred <- NA
level3tab.arnot1$thalf.pred <- NA
level3tab.arnot2 <- level3tab.arnot1
level3tab.arnot1$QSAR <- "QSARINS"
level3tab.arnot2$QSAR <- "IFS-QSAR"
for (this.dtxsid in level3.arnot$test_substance_dtxsid)
{
  level3tab.arnot1[level3tab.arnot1$DTXSID==this.dtxsid,"thalf.pred"] <- 
    as.numeric(level3.arnot[level3.arnot$test_substance_dtxsid==this.dtxsid,
    "QINS_Hum_HLT_Hour"])                            
  level3tab.arnot2[level3tab.arnot1$DTXSID==this.dtxsid,"thalf.pred"]  <- 
    as.numeric(level3.arnot[level3.arnot$test_substance_dtxsid==this.dtxsid,
    "IFS_Hum_HLT_Hour"]) 
}

level3tab <- rbind(
  level3tab.invitro,
  level3tab.admet,
  level3tab.dawson,
  level3tab.pradeep,
  level3tab.opera,
  level3tab.arnot1,
  level3tab.arnot2)


# HTTK PBTK with in vitro
# HTTK PBTK with ADmet
# HTTK PBTK with Pradeep
# HTTK PBTK with Dawson
# HTTK PBTK with OPERA
# ADmet predictor

#Figure Vd pred vs. observed
#Figure t_half pred vs. observed


level3tab$thalf.RPE <- 
  (level3tab$thalf.pred - level3tab$thalf.obs)/level3tab$thalf.obs
level3tab$Vd.RPE <- (level3tab$Vd.pred - level3tab$Vd.obs)/level3tab$Vd.obs


FigLev3a <- ggplot(data=level3tab) +
  geom_point(size=3,aes(x=thalf.pred,y=thalf.obs,shape=QSAR,color=QSAR))+
  scale_x_log10(label=scientific_10)+
  scale_y_log10(label=scientific_10)+
  scale_shape_manual(values=c(15, 16, 17, 18, 25,0,1,2,5))+
  geom_abline(intercept = log10(10^(1/2)), slope = 1,linetype="dashed", colour="lightBlue") +
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="Grey") + 
  geom_abline(intercept = log10(10^(-1/2)), slope = 1,linetype="dashed", colour="lightBlue") + 
  xlab(bquote('Predicted'~t[half]~"(h)")) +
  ylab(bquote('Observed'~t[half]~"(h)")) +
  theme_bw()+
  theme( text  = element_text(size=20))
print(FigLev3a)




FigLev3b <- ggplot(data=level3tab, aes(x=QSAR, y=thalf.RPE)) + 
#  geom_hline(yintercept=1,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
  geom_boxplot(outlier.colour="red",
    outlier.size=2,
    outlier.alpha=0.1)+
  xlab("QSAR") +
  ylab(bquote('Relative Prediction Error in '~t[half]~"(h)")) +
  scale_y_continuous(limits=c(-2,12)) +
#  scale_y_log10(breaks=c(10^-2,10^-1,1,3,10,10^2,10^3),label=scientific_10)+
  theme_bw()+
  theme( text  = element_text(size=20))   +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
print(FigLev3b) 

FigLev3c <- ggplot(data=subset(level3tab,!(QSAR %in% c("IFS-QSAR","QSARINS")))) +
  geom_point(size=3,aes(x=Vd.pred,y=Vd.obs,shape=QSAR,color=QSAR))+
  scale_y_log10(label=scientific_10)+
  scale_shape_manual(values=c(15, 16, 17, 18, 25,0,1,2,5))+
  geom_abline(intercept = log10(10^(1/2)), slope = 1,linetype="dashed", colour="lightBlue") +
  geom_abline(intercept = 0, slope = 1,linetype="solid", colour="Grey") + 
  geom_abline(intercept = log10(10^(-1/2)), slope = 1,linetype="dashed", colour="lightBlue") + 
  xlab(bquote('Predicted'~V[d]~"(L/kg BW)")) +
  ylab(bquote('Observed'~V[d]~"(L/kg BW)")) +
  theme_bw()+
  theme( text  = element_text(size=20))
print(FigLev3c)




FigLev3d <- ggplot(data=subset(level3tab,!(QSAR %in% c("IFS-QSAR","QSARINS"))), 
  aes(x=QSAR, y=Vd.RPE)) + 
#  geom_hline(yintercept=1,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=3,linetype = "dashed",color="blue")+
#  geom_hline(yintercept=10,linetype = "dashed",color="blue")+
  geom_boxplot(outlier.colour="red",
    outlier.size=2,
    outlier.alpha=0.1)+
  xlab("QSAR") +
  ylab(bquote('RPE in '~V[d]~"(L/kg BW)")) +
  scale_y_continuous(limits=c(-1.2,1)) +
#  scale_y_log10(breaks=c(10^-2,10^-1,1,3,10,10^2,10^3),label=scientific_10)+
  theme_bw()+
  theme( text  = element_text(size=20))+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
print(FigLev3d)  
```                 
                